{"pages":[],"posts":[{"title":"hexo与github建站记","text":"前一段时间Google开放了.app的域名申请，当时我搜了一下自己想要的一个域名，但是感觉有点小贵就没下手，没想到过了几天这个域名就没了。所以火急火燎的买了现在这个域名，但是一时间没想好要干嘛，思来想去的不如就建个小博客站吧。 准备阶段GitHub首先是先在自己的GitHub上创建一个新的Repository，名字为xxx.github.io，这个xxx必须是自己GitHub的用户名，否则不能成功。 创建好之后进入该项目的Settings，找到GitHub Pages 这里要选择自己的显示的分支，网上有人说一定要建gh-pages分支，其实没必要。另外Save之后就无法修改了，所以这里要注意一下。 GitHub Pages支持Jekyll，不过我用hexo，所以这个不用管了。 Custom domain这个是绑定自定义域名到你的github.io上。此处表面上是只能输入一个，实际上可以在项目里建立一个CNAME文件，往里面写入多个自己的域名都行。 Enforce HTTPS 这个重点说一下。今年五月份起 GitHub Pages“支持”HTTPS，这个支持的意思是从五月份起，新建的github.io都必须开启HTTPS，否则不能访问。这里就有个坑，此处暂时不表。 自定义域名网上域名商有很多，国内的域名商需要备案，网上很多人说建议在国外的域名商买域名，这个就见仁见智了，看自己需要。 有一点要注意的是，购买域名后要对域名的DNS做处理，否则是无法访问的。我这个域名实在GoDaddy上买的，GoDaddy的管理页就能设置域名的DNS域和转发网址，嫌麻烦的话其实在里面跟github.io绑定就行。 我用的是Dnspod，目前免费。使用方式是先注册，然后在里面的控制台添加域名（就是自己申请的自定义域名）。 添加完之后点进去，就可以添加记录： 网上一些帖子告诉你这里填的A记录的IP是错的，现在由于要使用HTTPS，所以要用troubleshooting-custom-domains这个页面内提供的四个IP： 185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 由于Dnspod只能免费填2个A记录，所以随便选2个IP填就是了。 之后要去自己买的域名的控制台那边修改DNS域： 图上是修改好的样子。 上述步骤完成后等一段时间，可以用dig命令（我是linux平台）检测一下自己的github.io和自定义域名的A记录是否一致。 坑这里就是1.1里提到的坑。当你设置完上述的所有东西之后，回到GitHub项目的Setting页，很大可能你会在GitHub Pages处看到两种提示，大概是： 自定义域名不支持HTTPS HTTPS证书正在处理下发 这两种提示2选1，都有可能出现。问题是第一个提示，这个非常误导人。我当时以为是我的哪个设置弄错了，折腾很久，还给github.com/contact发了个工单。 但实际上这两个提示根本没什么卵用，你所能做的就是等。一般一个晚上的时间就能好，实在不行就给github发工单。 HexoHexo是基于Node.js的，所以使用之前要先安装好Node，再用npm命令安装。 Hexo的使用其实很简单，主题页很多，官网提供的theme有大概200多个（吐槽一下，大多都是性冷淡色调，虽然我用的这个也是）。唯一要注意的是，网上很多比较过时的文章，里面提到的用法现在都不支持了。事实上官网本身就有简体中文的教程、文档，而且下面还有评论，多看看大概就知道怎么使用了 值得一提的是，Hexo的发布每次都是重新生成所有文件，再全部覆盖提交的GitHub上，所以要注意把不想被覆盖的文件添加到Hexo的source目录里。 还有一点是，Hexo发布到GitHub上的文件都是生成后的文件，Hexo自身的源文件不会上传上去。一种解决方法就是在自己的github.io项目上新建一个分支，将当前的Hexo文件都保存在新分之上。","link":"/article/default/86b00fba.html"},{"title":"你可能是数据推荐的受害者","text":"如果你是一名手机应用开发者，应该对友盟之类的统计SDK有所了解。如今这些第三方统计平台越来越吃香，因为各大厂商平台能利用这些数据做的事情，太多了。 最常见的，就是很多平台引以为荣的推荐系统。 最先让普通人体会到数据推荐的威力的，应该是网易云音乐。通过统计用户在网易云音乐上常听的音乐类型，逐步构建出一个用户的喜好模型，根据这个模型来为用户推荐音乐。从市场反应和用户反馈来看，这个推荐系统相当成功。 只要有效数据足够，方法论正确，通过手机收集到的用户数据和行为习惯，互联网公司真的比你自己更了解你。 何况这个时代，收集数据的不仅仅是手机APP，网页、搜索引擎、甚至是线下商店，大家都在无孔不入地收集每个人的数据。 有了这些数据，通过精准推荐，你永远都能在平台上看到你喜欢看的。 这样好吗？对于平台而言当然好，当用户发现这个平台好像大部分是自己感兴趣的内容，用户对平台的粘性就会变高，用数据表达的话，就是留存率增加，使用时长增长。 但是反过来说，对用户而言，你只能看到平台想你看的东西，或者说，你只能看到平台认为你想看的东西。 过去看新闻的时候，某些类型的新闻我可能比较关注，比如科技、民生类的，有一些是不太关注的，比如财经、国外政治类的。但是不关注不代表不看，比如某些时候可能我接触了一些其他知识，对某些之前不关注的新闻有了些许兴趣，那么当新闻实时发布出来时，我就能及时获取到信息；甚至就算不关注，但起码我会看到新闻标题，让我知道世界上发生了这么一回事。 现在看新闻，如果我点击科技、民生类的新闻比较多，可能过一段时间后，这个新闻平台就会开始自作主张地把这类型的新闻都推给你，而其他类的新闻在你浏览的版面上，占比会越来越少，甚至有段时间一条标题都看不到。 这意味着，数据推荐在迎合口味的同时，还把视野的广度给压缩了。这对很多人而言，会形成一种被动的“幸存者偏差”，仿佛这个社会就被你眼前“被推荐”的一切所充斥着，根本不会发生其他你不愿意了解的事情。 本来国家在信息屏蔽上就无所不用其极，数据推荐反而把这种趋势越推越烈。 举个例子，微博过去是很多突发、能让社会关注度很高的事件的消息始发地和传播地，过去刷微博的时候，会很容易就能刷到这些东西。但是近年以来，这些内容在用户充满被推荐的首页上很少出现到，甚至需要用户去搜索才能看到内容。 可以说，数据推荐在进一步加剧群众的无知。 其实数据推荐是一项很好的技术，精准的推荐系统能让广告收益更高，让平台更能抓住用户等等。但问题是，这些平台，好像很少能让用户选择是否接受推荐。 比如百度，如果我经常在百度上搜索计算机开发技术类的关键字，而某一天我可能希望搜索一些与此无关、但包含该关键字的内容，往往百度还是会优先在搜索结果上把技术类内容展示给我；又或者是知乎，知乎首页充斥着我关注的话题、我回答问题的相关内容和我提问的相关内容，但有时候我在知乎上并不只是想看这类东西。过去知乎还没有这种强相关的推荐首页时，可以在某个页面里看到其他人实时发的问题，这些问题涵盖不同方向类别，这让我可以挑一些还没人回答过的、对某些方面有经验或者兴趣的问题作答。而现在，知乎早就把这个功能去掉了。 如今数据推荐就像是应用里的隐私声明，你只能选择接受——说难听点，你只能选择被数据推荐强奸你的视野。事实是，数据推荐很有趣，但有的时候，我应该有选择不被推荐的权利。","link":"/article/default/4da69769.html"},{"title":"ViewPager配合Fragment懒加载的一个坑","text":"ViewPager搭配Fragment做懒加载，这个很常见。需要小心的是Fragment在ViewPager中的生命周期，这个不多说。 最近遇到一个坑，这个坑的关键点是 1ViewPager.setOffscreenPageLimit(); 假设通过这个方法设置了一个值（比如2），然后在ViewPager中滑动加载了2个Fragment后，第三个Fragment的加载会出现问题，具体表现是该调用的方法都有调用，但是就是数据加载出问题。 数据加载我是用了RxLifecycle绑定到FragmentEvent.DESTROY_VIEW，初步怀疑是生命周期在作祟。 目前的解决方法是先将setOffscreenPageLimit设置为和自己加入的Fragment数量一致。比较好的解决方法是自定义ViewPager实现懒加载。","link":"/article/dev/fbb3d3e5.html"},{"title":"The ABC of Dart Part 3","text":"类 - Class前面说到Dart中一切皆为对象。而所有对象都是类的实例，并且所有类都为Object的子类。 和其他语言一样，类也是用class关键字作为声明。 123class TestClass&#123; ...&#125; 构造函数Dart具有构造函数，跟C++不一样，没有析构函数。 1234class TestClass&#123; TestClass()&#123; &#125;&#125; 上述代码是标准写法。如果没有显示声明构造函数，类默认有一个无参数的构造函数。另外，Dart针对构造函数中没有内容的情况时提供了一种简写，比如上述代码可以简写如下： 123class TestClass&#123; TestClass(); //简写&#125; 没有函数重载！Dart中没有函数重载功能，当在同一个类中定义了一个名为func的函数后，后面不能再定义一个名字相同、但返回类型和参数类型不同的函数。 同样的，因为没有函数重载，构造函数也不存在重载，即当一个类中定义了一个构造函数后，就无法再定义一个相同名字、但构造不同的函数。 1234567class TestClass&#123; TestClass(); TestClass(int i)&#123; //TODO &#125;&#125; 如上述代码，IDE会提示错误，不允许编译。 命名构造函数那么，如果一个类确实需要多个构造函数时该怎么做呢？Dart提供了命名构造函数，即构造函数可以定义不同的名字，通过.来实现，如： 1234567class TestClass&#123; TestClass(); //默认的构造函数 TestClass.second(int i)&#123; //自定义命名的构造函数 //TODO &#125;&#125; 通过命名构造函数，可以实现如其他语言中类的构造函数重载的功能。 生成对象生成一个类的实例对象，通过new关键字实现，如下： 12var obj1 = new TestClass(); //默认的构造函数var obj2 = new TestClass.second(1); //自定义命名的构造函数 构造函数传参Dart中的类和Java一样，通过this关键字指向实例自身，因此标准的构造函数传参和Java一致： 1234567class TestClass&#123; int param; TestClass(int param)&#123; this.param = param; &#125;&#125; 同时，Dart在传参上也提供了简写，也是通过this关键字实现的： 1234567class TestClass&#123; int param1, param2; TestClass(this.param1, this.param2)&#123; //TODO &#125;&#125; 如上述代码，这样调用构造函数将自动把值传递给类的变量。如果构造函数只用于传递值，而不需要在里面做其他逻辑，则可以这样简写： 12345class TestClass&#123; int param1, param2; TestClass(this.param1, this.param2);&#125; 值得一提的是，在构造函数中也可以使用可选参数来定义参数。 生成不可变的对象Dart中可以用const修饰构造函数，这样通过该构造函数构建出来的对象是不可变的对象，此类对象可以赋值给final或const修饰的常量。 12345678910111213141516class TestClass&#123; final int p1, p2; TestClass(this.p1, this.p2)&#123; //TODO &#125; const TestClass.second(this.p1, this.p2);&#125;//生成对象//const TestClass obj1 = new TestClass(1,2); //报错const TestClass obj1 = const TestClass.second(1,2); //(1)final TestClass obj2 = const TestClass.second(1,2); //(2)final TestClass obj3 = new TestClass(1,2); //(3)var obj4 = new TestClass.second(1,2); //(4) 如上，除了注释掉的那一行会报错的以外，(1)、(2)、(3)、(4)行都可以编译运行。其中，被const所修饰的常量，赋值时必须用const来生成对象，不能用new；反过来，final所修饰的对象，用const或者new来生成对象都可以。 需要注意的是，使用const修饰构造函数时，其对应的类中的所有成员变量都必须用final修饰，并且不允许有函数body（即大括号{}包裹的逻辑语句）。 同时，由于成员变量被final修饰，所以构造函数必须用简写的模式来给变量赋值。例如： 12345678class TestClass&#123; int p1; final int p2; TestClass(int a ,this.p2)&#123; p1 = a; &#125;&#125; 上述代码中，因为变量p2被修饰为final，所以必须用简写模式赋值。 Getter &amp; Setter在Dart中，类中的成员变量、成员函数不存在访问权限这个概念，像Java中的private、public之类的并不存在。 123456789class TestClass&#123; int p1; int p2;&#125;//调用var testClass = new TestClass();testClass.p1 = 1;print(testClass.p2); 如上述代码中，任何人只要生成了类的实例对象，就可以通过对象来访问、修改这个类的成员变量。但这里又和其他的语言有点不同——在Dart中，之所以可以直接调用、修改实例的变量，是因为在Dart中类的所有成员变量默认有其隐式的相同名字的Getter和Setter，如果变量被final或const修饰，那么只有Getter没有Setter。 如果要显式定义某个变量的Getter或者Setter，则分别需要用get和set关键字来实现： 123456789101112131415161718192021222324252627class TestClass&#123; int p1; int p2; //int get p1 =&gt; p1;//报错 //set p1(int i) =&gt; p1 = i;//报错 int get myP1 =&gt; p1; int get myP2&#123; return p2; &#125; set myP1(int i) =&gt; p1 = i; set myP2(int i)&#123; p2 = i; &#125;&#125;//调用var testClass = new TestClass();testClass.myP1 = 1; //调用Setter方法myP1testClass.myP2 = 2; //调用Setter方法myP2print(testClass.myP1); //调用Getter方法myP1，打印1print(testClass.myP2); //调用Getter方法myP2，打印2 如上述代码，Getter和Setter的方法名可以相同。注意get修饰的Getter方法不能有()。set修饰的Setter方法后面带有()，但调用时不能用testClass.myP1(1)这种方式，而是用=来调用Setter方法。 前面说到，每个成员变量有其隐式的Getter和Setter，所以当我们自定义Getter、Setter时，命名不能用和成员变量一样的名字。 extends &amp; implements类的继承通过extends关键字来实现，基本实现和操作跟Java大致相同。 12345678910111213141516class BaseClass&#123; void func1()&#123; //TODO &#125; void func2()&#123; //TODO &#125;&#125;class TestClass extends BaseClass&#123; @override void func1()&#123; super.func1(); &#125;&#125; 如上，TestClass集成了BaseClass，因此可以选择性地改写BaseClass的方法。 而实现接口则通过implements关键字实现，与Java不同的是dart没有interface这个关键字，因为每一个类都是一个隐式接口。以上面的BaseClass为例： 123456789class TestClass2 implements BaseClass&#123; @override void func1()&#123; &#125; @override void func2()&#123; &#125;&#125; TestClass2通过implements实现了BaseClass内定义的方法func1()、func2()，虽然BaseClass在func1()、func2()里都有定义内容，但通过implements实现后，TestClass2并不会像extends一样默认执行BaseClass的方法。 抽象类抽象类通过abstract关键字修饰类： 123456789101112131415abstract class BaseClass&#123; void func();&#125;class TestClass extends BaseClass&#123; @override void func()&#123; &#125;&#125;class TestClass2 implements BaseClass&#123; @override void func()&#123; &#125;&#125; 可以看出，抽象类在继承和实现接口上并没有什么区别，都是强制要求实现抽象类中定义的函数。 和Java不同，dart只有抽象类，没有抽象方法。 mixin(混合)我们知道，实现接口时可以implements多个接口，每个接口用逗号隔开： 123class TestClass implements BaseClass1,BaseClass2&#123; ...&#125; 而继承只能继承一个类。某些时候，可能我们希望能继承多个类，不同的方法用不同类的实现方式——这时候，就可以使用dart提供的mixin(混合)模式。 mixin通过with关键字来实现。举个例子，现在分别有两个类ClassA和ClassB，通过这两个类组合成一个新的类ClassC，则表现为： ClassC = ClassA with ClassB 假设ClassA中所有方法的集合为\\(F_{A}\\)，ClassB中所有方法的集合为\\(F_{B}\\)，ClassC中所有方法的集合为\\(F_{C}\\)，则可理解为： $$F_{C}=F_{B} \\cup (F_{A}-F_{B})$$ 即ClassC中的所有方法为ClassA和ClassB的方法的集合，如果ClassA和ClassB中有重复的方法，则取ClassB的实现： 1234567891011121314151617181920212223class ClassA&#123; void func1()&#123; print(\"ClassA func1\"); &#125; void func2()&#123; print(\"ClassA func2\"); &#125;&#125;class ClassB&#123; void func1()&#123; print(\"ClassB func1\"); &#125;&#125;class ClassC = ClassA with ClassB;void main()&#123; ClassC classC = new ClassC(); classC.func1();//输出ClassB func1 classC.func2();//输出ClassA func2&#125; with关键字也可以通过逗号混合多个类。例如，目前分别有ClassA、ClassB、ClassC三个类，将该三个类组合成一个新类ClassD： ClassD = ClassA with ClassB,ClassC 这就相当于按顺序调用with： ClassD = (ClassA with ClassB) with ClassC 例子如下： 1234567891011121314151617181920212223242526272829303132333435363738class ClassA&#123; void func1()&#123; print(\"ClassA func1\"); &#125; void func2()&#123; print(\"ClassA func2\"); &#125; void func3()&#123; print(\"ClassA func3\"); &#125;&#125;class ClassB&#123; void func1()&#123; print(\"ClassB func1\"); &#125; void func2()&#123; print(\"ClassB func2\"); &#125;&#125;class ClassC&#123; void func1()&#123; print(\"ClassC func1\"); &#125;&#125;class ClassD = ClassA with ClassB,ClassC;void main()&#123; ClassD classD = new ClassD(); classD.func1();//输出ClassC func1 classD.func2();//输出ClassB func2 classD.func3();//输出ClassA func3&#125; 工厂构造函数使用factory修饰构造函数，具体意义不多说了，网上给出的例子都是方便调用者可以使用同一个对象，并不是单纯意义上的工厂设计模式。","link":"/article/dev/bd58250c.html"},{"title":"AudioTrack播放卡顿的现象","text":"最近用AudioTrack播放PCM数据时，在某台手机上播放出现了卡顿、噪音现象。经排查，发现是设置播放的Buffer Size出问题了。 一般使用AudioTrack，会使用AudioTrack.getMinBufferSize来获取一个最小的buffer size值，用于创建AudioTrack的实例；同时，会用这个size值来创建一个byte数组的buffer，用于从文件读取数据，这个buffer的大小一般取size/4。 但是size/4有可能会得出一个不能被2整除的数字，如果用这个数字创建了一个byte数组来读取文件并传入AudioTrack，就会产生卡顿、噪音等。所以创建buffer时需要确保把size/4的值转换成可被2整除的数。","link":"/article/dev/b6a55dfb.html"},{"title":"注意Tween Animation对Activity生命周期的影响","text":"最近遇到一个神奇的问题——一个Activity调用finish()后，该页面的onStop()和onDestroy()间隔大概十秒后才被调用。 分别谷歌、百度了一下这种现象，资料很少，而且说法各不相同，都不适用于我的这种情况。后来排查了一天，终于定位到了原因：Tween Animation。 起因是，我在A页面里有一个自定义控件，这个控件通过Tween Animation实现上下翻转信息流的动画效果。如果当这个控件只有一个信息，不进行动画时，启动B页面，然后B页面调用finish()，则onStop()、onDestroy()如期执行；如果A页面的控件多于一个信息，进行动画时，启动B页面再finish()，则onStop()、onDestroy()会延迟10s左右被调用。 至于为什么Tween Animation会影响到生命周期，具体原因未知，我尝试翻看了一下View的源代码，并没有什么发现，与此比较类似的问题可以看下这篇文章：Android 坑档案：背黑锅的 Fragment。 不过，从这个问题也能引申出一些结论： 尽量使用Property Animation而非Tween Animation，Tween Animation本质是View在draw的过程中执行的，Tween Animation依赖于View的绘制、并且可能影响View的生命周期进而影响Activity；而Property Animation则不依赖View的绘制，不会对生命周期产生影响。 不要依靠Activity的onStop()、onDestroy()方法来执行回收、停止等类似的操作。说到底，onStop()、onDestroy()都是依靠底层的消息机制来通知回调的，它并不能确保每次都准时回调。所以最好的方法，是在onPause()中通过判断isFinishing()当前页面是否正在关闭。","link":"/article/dev/3e198513.html"},{"title":"The-ABC-of-Dart-Part-4","text":"集合(Collection)Dart中提供的集合容器分别是我们常见的List、Map、Set，但它也只有这三种类型的集合，并不像其他语言会细分到ArrayList、LinkedList之类的。 List(列表 &amp; 数组)在Dart中没有数组的概念，取而代之的是用List来代替数组的功能。 所以在List的构造函数中，有一个构造函数是传入长度来创建对象，该List对象为固定长度的列表，无法改变长度。 123456var list1 = new List();list1.length = 3;list1.length = 5;var list2 = new List(3);list2.length = 5;//error 如上，通过List()创建的列表list1可以动态更改长度，而通过List(int length)创建的列表list2则无法更改长度。 创建一个List也可以通过简略的方式实现： 1var list = [1, 2, 3]; 如上，可以通过现成数据创建List，创建方式为用中括号[]加上数据，数据之间用逗号隔开。 前面也说了，List代替了数组功能，因此它也实现了数组的功能： 123var list = [1, 2, 3];print(list[0]);//打印1list[1] = 4; 如上，可以通过使用数组的形式来调用List中的子项。 最主要的是以上几点，其他的像List的其他构造函数、其他使用方法，在源代码中的list.dart中描述得很详细了，可以对照着使用。 MapMap的初始化也和其他类相似，当然它也有简略的方式： 1234var map = &#123; \"a\": 1, \"b\": 2&#125; 如上，可以用大括号{}包住已有数据，其中的数据为一个个的键值对，每个键值对用冒号:分割，冒号前的为key，冒号后的为value。 Map的使用方式也和List相同： 1234567var map = &#123; \"a\": 1, \"b\": 2&#125;print(map[\"a\"]);map[\"b\"] = 3; 和List不同的是，中括号中的是Map里的key，而List是对应的序号。 SetSet是无序的，并且内部元素在Set中是唯一的。因此，Set无法像List一样通过序号来访问数据；还有一点，Set没有像List那样的简略的构造方式： 12var set1 = new Set();var set2 = new Set.from([1, 2, 3]); 注：from构造函数以上三个集合容器都有 要访问Set中的任意一个值，则需要通过elementAt()函数： 123var set = new Set.from([\"A\", \"B\", \"C\"]);print(set.elementAt(1));//打印B","link":"/article/dev/a2cf4cff.html"},{"title":"The ABC of Dart Part 6","text":"库类的引用Dart中除了最基本的类型对象外，还提供了很多不同功能的库或类，比如一些异步操作、IO操作等等，这些都被一一封装到Dart的SDK中，由一个个独立的.dart文件承载着。 举个例子，在Java中，如果要使用某个类的功能，需要先通过import把该类引用进来。同样的，Dart也需要这种操作。 目前我使用的Android Studio 3.1.3，比较不好的一点是写Dart时不能像Java一样自动引用对应的库。 Pub包管理器了解库类的引用前，先学习一下Dart中的Pub包管理器。 Pub有点像Android项目中的Gradle——Gradle管理下的Android项目，我们用build.gradle来管理项目中的引用和其他配置；同样的，Dart也有pubspec.yaml来管理引用。 一般地，一个Dart项目的根目录下，包含有lib文件夹和pubspec.yaml文件。该文件包含了一个包的元数据，例如包的名称等。所以一个Dart项目也是一个包。 举个例子，一个最简单的pubspec.yaml内容如下： 1234name: testdeppendencies: cupertino_icons: ^0.1.2 name表示该包的名称，而deppendencies下的每一项则表示该包的引用。上述内容就表示了一个名叫test的包，这个包引用了一个名为cupertino_icons，版本号为0.1.2的包。 这里的版本号写法为^0.1.2，表示该版本号的约束为&gt;=0.1.2 &lt;0.2.0，这种写法为Caret语法，关于这点不作详细描述。 关于更多的有关pub的操作（例如配置项目资源、使用pub的命令行命令等）就不再阐述，此类操作可以等需要用到时再查找。 importDart中的import用法和Java基本相同，不同的是import后缀的引用路径： 1234567891011121314//\"dart:\"前缀表示Dart的标准库import 'dart:async';//同文件夹下的dartimport 'lib1.dart';//同路径下的其他文件中的dartimport 'lib2/lib2.dart';//绝对路径import '../lib3/lib3.dart';//通过包名+路径import 'package:test/lib1.dart'; 其中通过包命+路径的引用方式，结合上述的Pub，可知我在本项目中的pubspec.yaml里引用了一个名为test的包，则我可以在项目内的.dart文件里通过前缀package:加上包名+库类在该包内的路径来引用相应的库类。 命名冲突很多时候，我们引用的库类可能存在名称相同的情况，比如： 12345import 'p1/lib1.dart';import 'p2/lib2.dart';//编译器提示异常MyClass myClass = new MyClass(); 如上，我在lib1.dart和lib2.dart中都定义了一个名为MyClass的类，当我在引用处使用MyClass时，编译器提示我这个类在lib1.dart和lib2.dart都有定义，因此无法编译。 针对这种情况，可以使用as关键字，对某个引用声明其命名空间： 12345import 'p1/lib1.dart' as lib1;import 'p2/lib2.dart' as lib2;lib1.MyClass myClass1 = new lib1.MyClass();lib2.MyClass myClass2 = new lib2.MyClass(); 如上，通过声明不同的命名空间，则可以在调用时通过对应的命名空间即可。 部分引用有时候，我们可能只希望引用一个.dart文件中的某些库类，而不是引用其全部内容，则可以通过关键字show和hide来实现。 顾名思义，show表示只引用一个文件中的指定类；而hide则表示除指定类外其他类都引用。它们都可以通过逗号指定多个类： 12import 'p1/lib1.dart' show MyClass1,MyClass2;import 'p2/lib2.dart' hide MyClass3; librarylibrary关键字可以定义一个.dart文件（即一个库）的名字，但不影响库的引用，因为引用都是通过文件路径。 之所以要定义名字，是因为这个要配合part、part of关键字来使用。 例如，当我要维护一个库math，这个库包含项目需要的所有数学方法，比如加减乘除，那么这个库可以通过part来将不同的功能放到不同的.dart文件中，达到将库分散、细化粒度的效果。 123456library math;part 'plus.dart';part 'minus.dart';part 'multiply.dart';part 'divide.part'; 如上，我可以创建一个math.dart文件，这个文件路径在lib/math文件夹下。math.dart文件内部只有上述内容，因为具体实现功能都分散给各.dart文件来实现。 相应地，part修饰的各个文件内部，都需要通过part of来声明自身属于哪个库： 1part of math; 所以在plus.dart等四个文件中，开头都需要通过上述代码声明自己属于math这个库中。 关于library、part、part of，可以再看看Dart的SDK，里面的很多库都是通过这种方式实现的。 exportexport的使用方式和import相同，但是意义却不一样。它表示在一个库中导出另一个库，这样当第三个库引用第一个库时，也能引用到第二个库的内容。 例如，我现在有lib1.dart、lib2.dart、lib3.dart三个文件，其中lib1.dart中的内容为： 12import 'lib2.dart';export 'lib2.dart'; 然后在lib3.dart中： 1import 'lib1.dart'; 这样，即使lib3.dart中没有导入lib2.dart，也可以用到lib2.dart内的内容。 关于export的实际应用可以看一下这篇文章：organizing-a-library-package。","link":"/article/dev/cd32d183.html"},{"title":"The ABC of Dart Part 5","text":"操作符重载Dart可以像C语言一样重载部分操作符。支持重载的操作符有： &lt; + ^ [] &gt; / &amp; []= &lt;= ~/ &lt;&lt; ~ &gt;= * &gt;&gt; == – % 重载通过operator关键字实现： 123456789101112131415161718class Point&#123; int x; int y; Point(this.x, this.y); //重载加号运算符 Point operator +(Point point)&#123; return new Point(x + point.x, y + point.y); &#125;&#125;void main()&#123; Point p1 = new Point(1,2); Point p2 = new Point(3,4); print((p1 + p2).x);//打印4 print((p1 + p2).y);//打印6&#125;","link":"/article/dev/543b8039.html"},{"title":"The ABC of Dart Part 1","text":"前言近期对Flutter有兴趣，但这个东西要用Dart来写应用，只能先入门一下这门语言。 目前把基础看了一部分，总体而言，Dart和目前比较火热的JavaScript、Kotlin一样是一门脚本式语言，支持函数式编程，函数依然是第一公民，不过Dart对于对象的支持和定义更详细。另外，Dart运行在自己的Dart VM上，和其他的JVM语言不同，所以无论是使用Flutter或者是Dart，都需要先安装Dart VM。 至于IDE，我用的Android Studio，安装上Dart插件即可。 Hello World!和C语言一样，Dart的程序入口在main函数： 123void main()&#123; print(\"Hello World\");&#125; 三行代码就可以在一个*.dart文件中运行，不需要import什么东西。 对象类型之所以说是“对象类型”，是因为在Dart中一切皆为对象，只是针对不同的对象有不同的默认类型。因此，所有对象的默认值都为null，判空不用像js那么夸张了。 Object先介绍Object，就如上面所说，一切类型都是Object或者Object派生的。如果点开Dart中的object.dart，第一句注释就是： The base class for all Dart objects. 即所有类型都隐藏式继承了Object，如Java一样。 dynamicdynamic表示任意未知类型。注意未知这个词。在Dart中，Object和dynamic都能表示所有类型。关于这一点，刚开始接触时确实很困惑——既然Object已经能表示一切类型，那dynamic是用来干嘛的？ 举个例子，我创建一个类ClassA，其中的有一个成员函数为a： 12345class ClassA&#123; void a()&#123; //TODO &#125;&#125; 我声明一个函数，叫做func1，假设函数定义如下： 1234void func1(Object object)&#123; object.toString(); //(1) object.a(); //(2)&#125; 因为ClassA默认继承了Object，所以在给func1这个函数传参时，我们可以传入ClassA的实例。但是在编译时，编译器会报错，告诉我们第(2)行代码是不能编译过去的。因为函数func1声明了函数参数类型为Object，它只能调用Object的方法。 但如果我把func1的参数改为dynamic： 1234void func1(dynamic object)&#123; object.toString(); //(1) object.a(); //(2)&#125; 此时编译器则可以编译运行。 为什么呢？前面已经说了，Object是所有类的基类，而dynamic代表任意未知类型。两者功能基本一样，但是当使用dynamic来声明参数时，你可以通过该参数调用任意函数或变量，而编译器不会报任何异常。因为dynamic修饰的变量在编译器眼中看来，它是属于未知的，编译器不知道这个变量是否真的有这个函数或者变量，所以编译器选择闭嘴。 所以什么时候应该显示声明参数为dynamic呢？比如说我有一个类ClassA和ClassB，它们是两个没有任何关系的类，但是它们有两个共同的函数a，那么函数func1就能接受ClassA和ClassB的实例并且在内部调用函数a，而编译器不会对此报错。 但是官方也说到，最好还是不要用这种方式，dynamic应该尽可能不用，因为它不会被编译器检查，这样会导致程序不安全，程序员看着也很难猜测这种参数是什么类型。毕竟动态语言太过于“动态”就很难看了。 值得一提，Dart的静态检查和动态检查都很优秀，语言虽然是动态的，但是写起来跟静态强类型的语言相差不大。 var很多语言都有var关键字，作用基本都一样，表示类型为动态推断类型，编译器会将var声明的东西根据赋值反推类型。比如： 12var p1 = 1;var p2 = \"2\"; 在IDE中，这样在IDE中，能实时看到p1的static type为int，p2的static type为String。通过打印各自的runtimeType，也能看到和上述static type相似。 接下来有一点就有点意思了。如果我这样写： 123var p3; //(1)p3 = 1; //(2)p3 = \"2\"; //(3) 如果这样写，是可以编译、运行的（我目前的版本为Dart VM Version: 2.0.0-dev.54.0，往后的版本就不好说了）。 因为在（1）中，p3被动态推断为dynamic类型，所以在（2）中p3可以赋值为int，在（3）中可以赋值为String。在IDE中可以看到p3的static type为dynamic，而分别打印（2）、（3）时的runtimeType则分别为int和String。 所以，使用var最好是及时赋值，让编译器可以推断出实际类型，否则推断出类型为dynamic后，往后调用可能会出现不安全的情况。 num所有数字类型都继承自num，而数字类型也就只有2个： int - 表示任意长度的整数 double - 表示双精度浮点数 Dart中没有float、long、short、byte这些类型，统统用以上两种表示。 String字符串类型。顺带一提Dart也没有char类型。 Dart中的字符串支持+操作符，即： 12String str1 = \"abc\";String str2 = str1 + \"d\"; //str2 = \"abcd\" String支持在字符串中插入变量和代码，如： 123String str1 = \"abc\";String str2 = \"$str1\"; //str2 = \"abc\"String str3 = \"$&#123;str1.compareTo(str2)&#125;\" //str3 = \"true\"; 字符串前面加r，可以避免转义作用，声明该字符串为原始字符串： 12String str1 = \"\\n\";//输出换行String str2 = r\"\\n\";//输出\"\\n\" bool布尔类型，这个不用多说。 这些就是常用的基本类型，剩下的容器类型迟些再说。 const和finalconst和final都用于修饰不可修改的常量，唯一的不同点是在其声明时： const声明的常量是编译时常量，即编译时就需要确定值，所以声明时需要指定明确的值。 final声明的常量是运行时常量，即实际运行时才确定常量的值。 例如： 12345const int p1 = 1; //(1)final int p2 = 2; //(2)const int p3 = p1.compareTo(p2); //(3)final int p4 = p1.compareTo(p2); //(4) 在上面的代码中，（1）、（2）、（4）都可以编译运行，（3）在编译时则会提示错误。","link":"/article/dev/53564420.html"},{"title":"The ABC of Dart Part 2","text":"函数函数的写法跟其他语言基本大同小异，如下： 123int func1(String str)&#123; return int.parse(str);&#125; 在以上的函数func1中，声明了返回值为int类型的对象，函数参数为String，这是一种标准写法。 函数的简写动态脚本语言，或者函数式编程语言，特点之一就是函数可以简写，如： 12345678910111213int func1(String str)&#123; return 1;&#125;func2(String str)&#123; return 1;&#125;func3(str)&#123; return 1;&#125;func4(str) =&gt; 1; 因为在Dart中类型是可选的，所以像函数func2缺省声明返回值类型、函数func3缺省声明参数类型的写法都可以，在这种情况下，编译器默认将缺省声明类型的都声明为dynamic。不过个人建议还是不要这样省略，dynamic会让程序员感到困惑。 函数func4是Dart提供的一种新的写法，类似于Java的lambda，当函数内只有一行语句时，可以用=&gt;来简写，即func4代表的函数类型和func3、func2一样。 函数对象 - Function前面说过，Dart中一切皆为对象，函数也不例外，它的对象类型为Function。 12345void func1(String str)&#123; //TODO...&#125;print(func1 is Function);// 打印true 像这样，通过Dart的is关键字用来判断类型，可知函数func1的类型就是Function。 但就我的理解，Function对于函数而言，就是一个基类。所有函数都的类型都基于Function，而每一种函数都有其特定的类型。 比如，上述的函数func1，可以用对象的概念套进去，即func1的基本类型是Function，实际类型是(String) -&gt; void，而fucn1则是这个实际类型的实例的名称。 我认为，需要先理解这个概念，才能明白为何把函数称为第一公民，为何认为一切皆对象。不仅仅是Dart这么语言，目前大多的动态语言、函数式语言都是类似的这种设定。 闭包函数作为一种对象，既然有匿名对象，也就有匿名函数，如下： 12345678//(1)(String name) =&gt; \"Hello $name\";//(2)(name)&#123;print(\"Hello $name\");return 1;&#125; 像(1)、(2)这种把函数名、返回类型缺省的写法就是匿名函数。得益于函数也是对象这个概念，匿名函数这种写法才能实现。 以(1)为例子，匿名函数的写法舍去了函数名和返回类型，编译器会自动推断这段函数的返回类型，同时这段函数的实际类型为(String) -&gt; String。 如果这样一看，就像把一段封装好的逻辑包裹在函数这个对象的体内，因为函数自为对象，所以这个函数具备传递性，它可以被任意拿去调用，而不再像面向对象的语言一样，函数方法依附于实体类，这里就引申出函数式编程最重要的概念：闭包。 函数作为一种对象，因此可以作为返回值，也可以作为参数被传递。关于闭包的概念，寥寥几句无法说得清除。这里给出一种比较思路：比如在Java中，函数方法是作为一个对象的成员，我们要调用一个函数方法，调用它的这段逻辑，必须先传递对象，获取对象；反过来在Dart中，我们也是需要传递对象、获取对象，只是函数此时变成了一个对象，实际上我们依然在跟对象打交道，只是函数对象的出现使得一段逻辑本身就能被打包成一个可传递可获取的对象。 但是闭包不仅限于表示一段函数，而是一段包含了上下文环境的函数，这里还是不多说，只用一段代码表示一下 1234var func = (int a)&#123; int b = 4; return (int c) =&gt; a - b - c;&#125;(1); 在这段代码中，这段代码先定义了一段匿名函数，我们把该匿名函数叫做f1，f1的类型为(int) -&gt; Function，表示返回值是函数。然后我在匿名函数f1后面写上(1)，表示调用f1，传入参数1。f1的内部声明了一个变量int b = 4，并返回了一段匿名函数，我们把这段匿名函数叫做f2，f2的类型为(int) -&gt; int。因为我们调用了f1，所以立刻返回了f2并赋值给声明为动态推断类型的变量func，所以func的类型就是Function，它的实际类型就是f2这段函数。 注意这里的f2函数，其实携带着它的上下文环境——即int b = 4这个变量的。关于这个上下文环境不再多说，此处只作为一个例子。而从这个例子也可以得知，闭包的内存消耗比一般的对象可能要大，因为它包含了上下文环境。 回到开头所说的匿名函数，因为它缺省了函数名，所以在声明一段匿名函数时，必须立刻给它赋值，或者立刻执行它。所以开头的代码(1)、(2)应该这样写： 12345678//(1)var func1 = (String name) =&gt; \"Hello $name\";//(2)(name)&#123;print(\"Hello $name\");return 1;&#125;(\"world\"); 注意： 将匿名函数赋值给某个变量时，需要将变量声明为var或Function。 匿名函数无法在函数外或类外立刻调用，只能声明。 typedeftypedef是Dart中的关键字。我的理解是用于定义函数类型，即将一种函数类型定义成一种对象；而网上的说法是typedef用于定义函数类型的别名。 1typedef int Compare(Object a, Object b); 在上述代码中，将(Object, Object) -&gt; int这种函数的实际类型给予了一个具体的名称Compare，这意味着，一旦任何一个函数的实际类型是(Object, Object) -&gt; int，则这个函数的实际类型等同于Compare。例如： 12345int compareFunc(Object a1, Object b1)&#123; return 0;&#125;print(compareFunc is Compare);//打印true 上述代码中的函数compareFunc的实际类型为(Object, Object) -&gt; int，所以用is来与Compare作判断的结果为true。 之前说过Function代表函数类型，所以作为一种类型，也是可以定义为函数的返回值类型和参数类型。如： 123Function getFunc(int a)&#123; return (int b) =&gt; b - a;&#125; 因为用typedef定义了一段函数类型的名字，所以可以用该名字作为返回值类型或参数类型，如： 12345Compare getFunc(int i)&#123; return (Object a,Object b)&#123; return i; &#125;;&#125; 可选参数可选参数是Dart在函数上增加的新特性，作用如名字一样，当在函数中声明了可选参数，在调用该函数时我们可以选择是否传递该可选参数。 可选参数有两种： 命名可选参数命名可选参数用大括号{}包围，默认值可用:或=来赋值。 12345678void func(int a, &#123;int b:3, c, d&#125;)&#123; //TODO&#125;//调用func(1); //(1)func(1,b:4); //(2)func(1,c:5); //(2) 上述代码中，我们定义了func函数，函数参数中必须要传的是a，剩下的是可传可不传的参数b、c、d，我们用大括号包围。其中某些可选参数我们想要有一个默认值，可以在声明时就用:或者=来赋值，如参数b。 在调用时，我们可以只传必须要传的参数，如(1)。如果我们想要传入某些参数，比如我们要传入参数b，则可以如(2)一样调用，注意因为是命名可选参数，所以在传入可选参数时必须声明传给哪个参数。 位置可选参数位置可选参数用方括号[]包围，默认值用=来赋值。 1234567void func(int a , [int b = 3, c, d])&#123; //TODO&#125;//调用func(1); //(1)func(1,2,3); //(2) 上述代码中，我们定义了func函数，函数参数中必须要传的是a，剩下的是可传可不传的参数b、c、d，我们用中括号包围。其中某些可选参数我们想要有一个默认值，可以在声明时就用=来赋值，如参数b。 表面上，位置可选参数和命名可选参数区别不大。实际上它们的区别在调用时的传参：命名可选参数传参时必须声明传给哪个参数，而位置可选参数则是按顺序来传值的。在(1)中只传必须参数时和命名可选参数一样。但在(2)中可以看到，传参时不需要声明参数名，当我们传入的参数为1、2、3时，函数将分别把参数赋值到a、b、c中。","link":"/article/dev/ca5f159a.html"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Dart","slug":"Dart","link":"/tags/Dart/"}],"categories":[{"name":"骚灵","slug":"default","link":"/categories/default/"},{"name":"开发","slug":"dev","link":"/categories/dev/"}]}