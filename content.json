{"pages":[],"posts":[{"title":"The ABC of Dart Part 1","text":"前言近期对Flutter有兴趣，但这个东西要用Dart来写应用，只能先入门一下这门语言。 目前把基础看了一部分，总体而言，Dart和目前比较火热的JavaScript、Kotlin一样是一门脚本式语言，支持函数式编程，函数依然是第一公民，不过Dart对于对象的支持和定义更详细。另外，Dart运行在自己的Dart VM上，和其他的JVM语言不同，所以无论是使用Flutter或者是Dart，都需要先安装Dart VM。 至于IDE，我用的Android Studio，安装上Dart插件即可。 Hello World!和C语言一样，Dart的程序入口在main函数： 123void main()&#123; print(\"Hello World\");&#125; 三行代码就可以在一个*.dart文件中运行，不需要import什么东西。 对象类型之所以说是“对象类型”，是因为在Dart中一切皆为对象，只是针对不同的对象有不同的默认类型。因此，所有对象的默认值都为null，判空不用像js那么夸张了。 Object先介绍Object，就如上面所说，一切类型都是Object或者Object派生的。如果点开Dart中的object.dart，第一句注释就是： The base class for all Dart objects. 即所有类型都隐藏式继承了Object，如Java一样。 dynamicdynamic表示任意未知类型。注意未知这个词。在Dart中，Object和dynamic都能表示所有类型。关于这一点，刚开始接触时确实很困惑——既然Object已经能表示一切类型，那dynamic是用来干嘛的？ 举个例子，我创建一个类ClassA，其中的有一个成员函数为a： 12345class ClassA&#123; void a()&#123; //TODO &#125;&#125; 我声明一个函数，叫做func1，假设函数定义如下： 1234void func1(Object object)&#123; object.toString(); //(1) object.a(); //(2)&#125; 因为ClassA默认继承了Object，所以在给func1这个函数传参时，我们可以传入ClassA的实例。但是在编译时，编译器会报错，告诉我们第(2)行代码是不能编译过去的。因为函数func1声明了函数参数类型为Object，它只能调用Object的方法。 但如果我把func1的参数改为dynamic： 1234void func1(dynamic object)&#123; object.toString(); //(1) object.a(); //(2)&#125; 此时编译器则可以编译运行。 为什么呢？前面已经说了，Object是所有类的基类，而dynamic代表任意未知类型。两者功能基本一样，但是当使用dynamic来声明参数时，你可以通过该参数调用任意函数或变量，而编译器不会报任何异常。因为dynamic修饰的变量在编译器眼中看来，它是属于未知的，编译器不知道这个变量是否真的有这个函数或者变量，所以编译器选择闭嘴。 所以什么时候应该显示声明参数为dynamic呢？比如说我有一个类ClassA和ClassB，它们是两个没有任何关系的类，但是它们有两个共同的函数a，那么函数func1就能接受ClassA和ClassB的实例并且在内部调用函数a，而编译器不会对此报错。 但是官方也说到，最好还是不要用这种方式，dynamic应该尽可能不用，因为它不会被编译器检查，这样会导致程序不安全，程序员看着也很难猜测这种参数是什么类型。毕竟动态语言太过于“动态”就很难看了。 值得一提，Dart的静态检查和动态检查都很优秀，语言虽然是动态的，但是写起来跟静态强类型的语言相差不大。 var很多语言都有var关键字，作用基本都一样，表示类型为动态推断类型，编译器会将var声明的东西根据赋值反推类型。比如： 12var p1 = 1;var p2 = \"2\"; 在IDE中，这样在IDE中，能实时看到p1的static type为int，p2的static type为String。通过打印各自的runtimeType，也能看到和上述static type相似。 接下来有一点就有点意思了。如果我这样写： 123var p3; //(1)p3 = 1; //(2)p3 = \"2\"; //(3) 如果这样写，是可以编译、运行的（我目前的版本为Dart VM Version: 2.0.0-dev.54.0，往后的版本就不好说了）。 因为在（1）中，p3被动态推断为dynamic类型，所以在（2）中p3可以赋值为int，在（3）中可以赋值为String。在IDE中可以看到p3的static type为dynamic，而分别打印（2）、（3）时的runtimeType则分别为int和String。 所以，使用var最好是及时赋值，让编译器可以推断出实际类型，否则推断出类型为dynamic后，往后调用可能会出现不安全的情况。 num所有数字类型都继承自num，而数字类型也就只有2个： int - 表示任意长度的整数 double - 表示双精度浮点数 Dart中没有float、long、short、byte这些类型，统统用以上两种表示。 String字符串类型。顺带一提Dart也没有char类型。 Dart中的字符串支持+操作符，即： 12String str1 = \"abc\";String str2 = str1 + \"d\"; //str2 = \"abcd\" String支持在字符串中插入变量和代码，如： 123String str1 = \"abc\";String str2 = \"$str1\"; //str2 = \"abc\"String str3 = \"$&#123;str1.compareTo(str2)&#125;\" //str3 = \"true\"; 字符串前面加r，可以避免转义作用，声明该字符串为原始字符串： 12String str1 = \"\\n\";//输出换行String str2 = r\"\\n\";//输出\"\\n\" bool布尔类型，这个不用多说。 这些就是常用的基本类型，剩下的容器类型迟些再说。 const和finalconst和final都用于修饰不可修改的常量，唯一的不同点是在其声明时： const声明的常量是编译时常量，即编译时就需要确定值，所以声明时需要指定明确的值。 final声明的常量是运行时常量，即实际运行时才确定常量的值。 例如： 12345const int p1 = 1; //(1)final int p2 = 2; //(2)const int p3 = p1.compareTo(p2); //(3)final int p4 = p1.compareTo(p2); //(4) 在上面的代码中，（1）、（2）、（4）都可以编译运行，（3）在编译时则会提示错误。","link":"/article/dev/53564420.html"},{"title":"hexo与github建站记","text":"前一段时间Google开放了.app的域名申请，当时我搜了一下自己想要的一个域名，但是感觉有点小贵就没下手，没想到过了几天这个域名就没了。所以火急火燎的买了现在这个域名，但是一时间没想好要干嘛，思来想去的不如就建个小博客站吧。 准备阶段GitHub首先是先在自己的GitHub上创建一个新的Repository，名字为xxx.github.io，这个xxx必须是自己GitHub的用户名，否则不能成功。 创建好之后进入该项目的Settings，找到GitHub Pages 这里要选择自己的显示的分支，网上有人说一定要建gh-pages分支，其实没必要。另外Save之后就无法修改了，所以这里要注意一下。 GitHub Pages支持Jekyll，不过我用hexo，所以这个不用管了。 Custom domain这个是绑定自定义域名到你的github.io上。此处表面上是只能输入一个，实际上可以在项目里建立一个CNAME文件，往里面写入多个自己的域名都行。 Enforce HTTPS 这个重点说一下。今年五月份起 GitHub Pages“支持”HTTPS，这个支持的意思是从五月份起，新建的github.io都必须开启HTTPS，否则不能访问。这里就有个坑，此处暂时不表。 自定义域名网上域名商有很多，国内的域名商需要备案，网上很多人说建议在国外的域名商买域名，这个就见仁见智了，看自己需要。 有一点要注意的是，购买域名后要对域名的DNS做处理，否则是无法访问的。我这个域名实在GoDaddy上买的，GoDaddy的管理页就能设置域名的DNS域和转发网址，嫌麻烦的话其实在里面跟github.io绑定就行。 我用的是Dnspod，目前免费。使用方式是先注册，然后在里面的控制台添加域名（就是自己申请的自定义域名）。 添加完之后点进去，就可以添加记录： 网上一些帖子告诉你这里填的A记录的IP是错的，现在由于要使用HTTPS，所以要用troubleshooting-custom-domains这个页面内提供的四个IP： 185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 由于Dnspod只能免费填2个A记录，所以随便选2个IP填就是了。 之后要去自己买的域名的控制台那边修改DNS域： 图上是修改好的样子。 上述步骤完成后等一段时间，可以用dig命令（我是linux平台）检测一下自己的github.io和自定义域名的A记录是否一致。 坑这里就是1.1里提到的坑。当你设置完上述的所有东西之后，回到GitHub项目的Setting页，很大可能你会在GitHub Pages处看到两种提示，大概是： 自定义域名不支持HTTPS HTTPS证书正在处理下发 这两种提示2选1，都有可能出现。问题是第一个提示，这个非常误导人。我当时以为是我的哪个设置弄错了，折腾很久，还给github.com/contact发了个工单。 但实际上这两个提示根本没什么卵用，你所能做的就是等。一般一个晚上的时间就能好，实在不行就给github发工单。 HexoHexo是基于Node.js的，所以使用之前要先安装好Node，再用npm命令安装。 Hexo的使用其实很简单，主题页很多，官网提供的theme有大概200多个（吐槽一下，大多都是性冷淡色调，虽然我用的这个也是）。唯一要注意的是，网上很多比较过时的文章，里面提到的用法现在都不支持了。事实上官网本身就有简体中文的教程、文档，而且下面还有评论，多看看大概就知道怎么使用了 值得一提的是，Hexo的发布每次都是重新生成所有文件，再全部覆盖提交的GitHub上，所以要注意把不想被覆盖的文件添加到Hexo的source目录里。 还有一点是，Hexo发布到GitHub上的文件都是生成后的文件，Hexo自身的源文件不会上传上去。一种解决方法就是在自己的github.io项目上新建一个分支，将当前的Hexo文件都保存在新分之上。","link":"/article/default/86b00fba.html"},{"title":"ViewPager配合Fragment懒加载的一个坑","text":"ViewPager搭配Fragment做懒加载，这个很常见。需要小心的是Fragment在ViewPager中的生命周期，这个不多说。 最近遇到一个坑，这个坑的关键点是 1ViewPager.setOffscreenPageLimit(); 假设通过这个方法设置了一个值（比如2），然后在ViewPager中滑动加载了2个Fragment后，第三个Fragment的加载会出现问题，具体表现是该调用的方法都有调用，但是就是数据加载出问题。 数据加载我是用了RxLifecycle绑定到FragmentEvent.DESTROY_VIEW，初步怀疑是生命周期在作祟。 目前的解决方法是先将setOffscreenPageLimit设置为和自己加入的Fragment数量一致。比较好的解决方法是自定义ViewPager实现懒加载。","link":"/article/dev/fbb3d3e5.html"},{"title":"你可能是数据推荐的受害者","text":"如果你是一名手机应用开发者，应该对友盟之类的统计SDK有所了解。如今这些第三方统计平台越来越吃香，因为各大厂商平台能利用这些数据做的事情，太多了。 最常见的，就是很多平台引以为荣的推荐系统。 最先让普通人体会到数据推荐的威力的，应该是网易云音乐。通过统计用户在网易云音乐上常听的音乐类型，逐步构建出一个用户的喜好模型，根据这个模型来为用户推荐音乐。从市场反应和用户反馈来看，这个推荐系统相当成功。 只要有效数据足够，方法论正确，通过手机收集到的用户数据和行为习惯，互联网公司真的比你自己更了解你。 何况这个时代，收集数据的不仅仅是手机APP，网页、搜索引擎、甚至是线下商店，大家都在无孔不入地收集每个人的数据。 有了这些数据，通过精准推荐，你永远都能在平台上看到你喜欢看的。 这样好吗？对于平台而言当然好，当用户发现这个平台好像大部分是自己感兴趣的内容，用户对平台的粘性就会变高，用数据表达的话，就是留存率增加，使用时长增长。 但是反过来说，对用户而言，你只能看到平台想你看的东西，或者说，你只能看到平台认为你想看的东西。 过去看新闻的时候，某些类型的新闻我可能比较关注，比如科技、民生类的，有一些是不太关注的，比如财经、国外政治类的。但是不关注不代表不看，比如某些时候可能我接触了一些其他知识，对某些之前不关注的新闻有了些许兴趣，那么当新闻实时发布出来时，我就能及时获取到信息；甚至就算不关注，但起码我会看到新闻标题，让我知道世界上发生了这么一回事。 现在看新闻，如果我点击科技、民生类的新闻比较多，可能过一段时间后，这个新闻平台就会开始自作主张地把这类型的新闻都推给你，而其他类的新闻在你浏览的版面上，占比会越来越少，甚至有段时间一条标题都看不到。 这意味着，数据推荐在迎合口味的同时，还把视野的广度给压缩了。这对很多人而言，会形成一种被动的“幸存者偏差”，仿佛这个社会就被你眼前“被推荐”的一切所充斥着，根本不会发生其他你不愿意了解的事情。 本来国家在信息屏蔽上就无所不用其极，数据推荐反而把这种趋势越推越烈。 举个例子，微博过去是很多突发、能让社会关注度很高的事件的消息始发地和传播地，过去刷微博的时候，会很容易就能刷到这些东西。但是近年以来，这些内容在用户充满被推荐的首页上很少出现到，甚至需要用户去搜索才能看到内容。 可以说，数据推荐在进一步加剧群众的无知。 其实数据推荐是一项很好的技术，精准的推荐系统能让广告收益更高，让平台更能抓住用户等等。但问题是，这些平台，好像很少能让用户选择是否接受推荐。 比如百度，如果我经常在百度上搜索计算机开发技术类的关键字，而某一天我可能希望搜索一些与此无关、但包含该关键字的内容，往往百度还是会优先在搜索结果上把技术类内容展示给我；又或者是知乎，知乎首页充斥着我关注的话题、我回答问题的相关内容和我提问的相关内容，但有时候我在知乎上并不只是想看这类东西。过去知乎还没有这种强相关的推荐首页时，可以在某个页面里看到其他人实时发的问题，这些问题涵盖不同方向类别，这让我可以挑一些还没人回答过的、对某些方面有经验或者兴趣的问题作答。而现在，知乎早就把这个功能去掉了。 如今数据推荐就像是应用里的隐私声明，你只能选择接受——说难听点，你只能选择被数据推荐强奸你的视野。事实是，数据推荐很有趣，但有的时候，我应该有选择不被推荐的权利。","link":"/article/default/4da69769.html"}],"tags":[{"name":"Dart","slug":"Dart","link":"/tags/Dart/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"Android","slug":"Android","link":"/tags/Android/"}],"categories":[{"name":"开发","slug":"dev","link":"/categories/dev/"},{"name":"骚灵","slug":"default","link":"/categories/default/"}]}