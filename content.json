{"pages":[],"posts":[{"title":"hexo与github建站记","text":"前一段时间Google开放了.app的域名申请，当时我搜了一下自己想要的一个域名，但是感觉有点小贵就没下手，没想到过了几天这个域名就没了。所以火急火燎的买了现在这个域名，但是一时间没想好要干嘛，思来想去的不如就建个小博客站吧。 准备阶段GitHub首先是先在自己的GitHub上创建一个新的Repository，名字为xxx.github.io，这个xxx必须是自己GitHub的用户名，否则不能成功。 创建好之后进入该项目的Settings，找到GitHub Pages 这里要选择自己的显示的分支，网上有人说一定要建gh-pages分支，其实没必要。另外Save之后就无法修改了，所以这里要注意一下。 GitHub Pages支持Jekyll，不过我用hexo，所以这个不用管了。 Custom domain这个是绑定自定义域名到你的github.io上。此处表面上是只能输入一个，实际上可以在项目里建立一个CNAME文件，往里面写入多个自己的域名都行。 Enforce HTTPS 这个重点说一下。今年五月份起 GitHub Pages“支持”HTTPS，这个支持的意思是从五月份起，新建的github.io都必须开启HTTPS，否则不能访问。这里就有个坑，此处暂时不表。 自定义域名网上域名商有很多，国内的域名商需要备案，网上很多人说建议在国外的域名商买域名，这个就见仁见智了，看自己需要。 有一点要注意的是，购买域名后要对域名的DNS做处理，否则是无法访问的。我这个域名实在GoDaddy上买的，GoDaddy的管理页就能设置域名的DNS域和转发网址，嫌麻烦的话其实在里面跟github.io绑定就行。 我用的是Dnspod，目前免费。使用方式是先注册，然后在里面的控制台添加域名（就是自己申请的自定义域名）。 添加完之后点进去，就可以添加记录： 网上一些帖子告诉你这里填的A记录的IP是错的，现在由于要使用HTTPS，所以要用troubleshooting-custom-domains这个页面内提供的四个IP： 185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 由于Dnspod只能免费填2个A记录，所以随便选2个IP填就是了。 之后要去自己买的域名的控制台那边修改DNS域： 图上是修改好的样子。 上述步骤完成后等一段时间，可以用dig命令（我是linux平台）检测一下自己的github.io和自定义域名的A记录是否一致。 坑这里就是1.1里提到的坑。当你设置完上述的所有东西之后，回到GitHub项目的Setting页，很大可能你会在GitHub Pages处看到两种提示，大概是： 自定义域名不支持HTTPS HTTPS证书正在处理下发 这两种提示2选1，都有可能出现。问题是第一个提示，这个非常误导人。我当时以为是我的哪个设置弄错了，折腾很久，还给github.com/contact发了个工单。 但实际上这两个提示根本没什么卵用，你所能做的就是等。一般一个晚上的时间就能好，实在不行就给github发工单。 HexoHexo是基于Node.js的，所以使用之前要先安装好Node，再用npm命令安装。 Hexo的使用其实很简单，主题页很多，官网提供的theme有大概200多个（吐槽一下，大多都是性冷淡色调，虽然我用的这个也是）。唯一要注意的是，网上很多比较过时的文章，里面提到的用法现在都不支持了。事实上官网本身就有简体中文的教程、文档，而且下面还有评论，多看看大概就知道怎么使用了 值得一提的是，Hexo的发布每次都是重新生成所有文件，再全部覆盖提交的GitHub上，所以要注意把不想被覆盖的文件添加到Hexo的source目录里。 还有一点是，Hexo发布到GitHub上的文件都是生成后的文件，Hexo自身的源文件不会上传上去。一种解决方法就是在自己的github.io项目上新建一个分支，将当前的Hexo文件都保存在新分之上。","link":"/article/default/86b00fba.html"},{"title":"ViewPager配合Fragment懒加载的一个坑","text":"ViewPager搭配Fragment做懒加载，这个很常见。需要小心的是Fragment在ViewPager中的生命周期，这个不多说。 最近遇到一个坑，这个坑的关键点是 1ViewPager.setOffscreenPageLimit(); 假设通过这个方法设置了一个值（比如2），然后在ViewPager中滑动加载了2个Fragment后，第三个Fragment的加载会出现问题，具体表现是该调用的方法都有调用，但是就是数据加载出问题。 数据加载我是用了RxLifecycle绑定到FragmentEvent.DESTROY_VIEW，初步怀疑是生命周期在作祟。 目前的解决方法是先将setOffscreenPageLimit设置为和自己加入的Fragment数量一致。比较好的解决方法是自定义ViewPager实现懒加载。","link":"/article/dev/fbb3d3e5.html"},{"title":"你可能是数据推荐的受害者","text":"如果你是一名手机应用开发者，应该对友盟之类的统计SDK有所了解。如今这些第三方统计平台越来越吃香，因为各大厂商平台能利用这些数据做的事情，太多了。 最常见的，就是很多平台引以为荣的推荐系统。 最先让普通人体会到数据推荐的威力的，应该是网易云音乐。通过统计用户在网易云音乐上常听的音乐类型，逐步构建出一个用户的喜好模型，根据这个模型来为用户推荐音乐。从市场反应和用户反馈来看，这个推荐系统相当成功。 只要有效数据足够，方法论正确，通过手机收集到的用户数据和行为习惯，互联网公司真的比你自己更了解你。 何况这个时代，收集数据的不仅仅是手机APP，网页、搜索引擎、甚至是线下商店，大家都在无孔不入地收集每个人的数据。 有了这些数据，通过精准推荐，你永远都能在平台上看到你喜欢看的。 这样好吗？对于平台而言当然好，当用户发现这个平台好像大部分是自己感兴趣的内容，用户对平台的粘性就会变高，用数据表达的话，就是留存率增加，使用时长增长。 但是反过来说，对用户而言，你只能看到平台想你看的东西，或者说，你只能看到平台认为你想看的东西。 过去看新闻的时候，某些类型的新闻我可能比较关注，比如科技、民生类的，有一些是不太关注的，比如财经、国外政治类的。但是不关注不代表不看，比如某些时候可能我接触了一些其他知识，对某些之前不关注的新闻有了些许兴趣，那么当新闻实时发布出来时，我就能及时获取到信息；甚至就算不关注，但起码我会看到新闻标题，让我知道世界上发生了这么一回事。 现在看新闻，如果我点击科技、民生类的新闻比较多，可能过一段时间后，这个新闻平台就会开始自作主张地把这类型的新闻都推给你，而其他类的新闻在你浏览的版面上，占比会越来越少，甚至有段时间一条标题都看不到。 这意味着，数据推荐在迎合口味的同时，还把视野的广度给压缩了。这对很多人而言，会形成一种被动的“幸存者偏差”，仿佛这个社会就被你眼前“被推荐”的一切所充斥着，根本不会发生其他你不愿意了解的事情。 本来国家在信息屏蔽上就无所不用其极，数据推荐反而把这种趋势越推越烈。 举个例子，微博过去是很多突发、能让社会关注度很高的事件的消息始发地和传播地，过去刷微博的时候，会很容易就能刷到这些东西。但是近年以来，这些内容在用户充满被推荐的首页上很少出现到，甚至需要用户去搜索才能看到内容。 可以说，数据推荐在进一步加剧群众的无知。 其实数据推荐是一项很好的技术，精准的推荐系统能让广告收益更高，让平台更能抓住用户等等。但问题是，这些平台，好像很少能让用户选择是否接受推荐。 比如百度，如果我经常在百度上搜索计算机开发技术类的关键字，而某一天我可能希望搜索一些与此无关、但包含该关键字的内容，往往百度还是会优先在搜索结果上把技术类内容展示给我；又或者是知乎，知乎首页充斥着我关注的话题、我回答问题的相关内容和我提问的相关内容，但有时候我在知乎上并不只是想看这类东西。过去知乎还没有这种强相关的推荐首页时，可以在某个页面里看到其他人实时发的问题，这些问题涵盖不同方向类别，这让我可以挑一些还没人回答过的、对某些方面有经验或者兴趣的问题作答。而现在，知乎早就把这个功能去掉了。 如今数据推荐就像是应用里的隐私声明，你只能选择接受——说难听点，你只能选择被数据推荐强奸你的视野。事实是，数据推荐很有趣，但有的时候，我应该有选择不被推荐的权利。","link":"/article/default/4da69769.html"},{"title":"AudioTrack播放卡顿的现象","text":"最近用AudioTrack播放PCM数据时，在某台手机上播放出现了卡顿、噪音现象。经排查，发现是设置播放的Buffer Size出问题了。 一般使用AudioTrack，会使用AudioTrack.getMinBufferSize来获取一个最小的buffer size值，用于创建AudioTrack的实例；同时，会用这个size值来创建一个byte数组的buffer，用于从文件读取数据，这个buffer的大小一般取size/4。 但是size/4有可能会得出一个不能被2整除的数字，如果用这个数字创建了一个byte数组来读取文件并传入AudioTrack，就会产生卡顿、噪音等。所以创建buffer时需要确保把size/4的值转换成可被2整除的数。","link":"/article/dev/b6a55dfb.html"},{"title":"注意Tween Animation对Activity生命周期的影响","text":"最近遇到一个神奇的问题——一个Activity调用finish()后，该页面的onStop()和onDestroy()间隔大概十秒后才被调用。 分别谷歌、百度了一下这种现象，资料很少，而且说法各不相同，都不适用于我的这种情况。后来排查了一天，终于定位到了原因：Tween Animation。 起因是，我在A页面里有一个自定义控件，这个控件通过Tween Animation实现上下翻转信息流的动画效果。如果当这个控件只有一个信息，不进行动画时，启动B页面，然后B页面调用finish()，则onStop()、onDestroy()如期执行；如果A页面的控件多于一个信息，进行动画时，启动B页面再finish()，则onStop()、onDestroy()会延迟10s左右被调用。 至于为什么Tween Animation会影响到生命周期，具体原因未知，我尝试翻看了一下View的源代码，并没有什么发现，与此比较类似的问题可以看下这篇文章：Android 坑档案：背黑锅的 Fragment。 不过，从这个问题也能引申出一些结论： 尽量使用Property Animation而非Tween Animation，Tween Animation本质是View在draw的过程中执行的，Tween Animation依赖于View的绘制、并且可能影响View的生命周期进而影响Activity；而Property Animation则不依赖View的绘制，不会对生命周期产生影响。 不要依靠Activity的onStop()、onDestroy()方法来执行回收、停止等类似的操作。说到底，onStop()、onDestroy()都是依靠底层的消息机制来通知回调的，它并不能确保每次都准时回调。所以最好的方法，是在onPause()中通过判断isFinishing()当前页面是否正在关闭。","link":"/article/dev/3e198513.html"},{"title":"The ABC of Dart Part 1 - 基础","text":"前言近期对Flutter有兴趣，但这个东西要用Dart来写应用，只能先入门一下这门语言。 目前把基础看了一部分，总体而言，Dart和目前比较火热的JavaScript、Kotlin一样是一门脚本式语言，支持函数式编程，函数依然是第一公民，不过Dart对于对象的支持和定义更详细。另外，Dart运行在自己的Dart VM上，和其他的JVM语言不同，所以无论是使用Flutter或者是Dart，都需要先安装Dart VM。 至于IDE，我用的Android Studio，安装上Dart插件即可。 Hello World!和C语言一样，Dart的程序入口在main函数： 123void main()&#123; print(\"Hello World\");&#125; 三行代码就可以在一个*.dart文件中运行，不需要import什么东西。 对象类型之所以说是“对象类型”，是因为在Dart中一切皆为对象，只是针对不同的对象有不同的默认类型。因此，所有对象的默认值都为null，判空不用像js那么夸张了。 Object先介绍Object，就如上面所说，一切类型都是Object或者Object派生的。如果点开Dart中的object.dart，第一句注释就是： The base class for all Dart objects. 即所有类型都隐藏式继承了Object，如Java一样。 dynamicdynamic表示任意未知类型。注意未知这个词。在Dart中，Object和dynamic都能表示所有类型。关于这一点，刚开始接触时确实很困惑——既然Object已经能表示一切类型，那dynamic是用来干嘛的？ 举个例子，我创建一个类ClassA，其中的有一个成员函数为a： 12345class ClassA&#123; void a()&#123; //TODO &#125;&#125; 我声明一个函数，叫做func1，假设函数定义如下： 1234void func1(Object object)&#123; object.toString(); //(1) object.a(); //(2)&#125; 因为ClassA默认继承了Object，所以在给func1这个函数传参时，我们可以传入ClassA的实例。但是在编译时，编译器会报错，告诉我们第(2)行代码是不能编译过去的。因为函数func1声明了函数参数类型为Object，它只能调用Object的方法。 但如果我把func1的参数改为dynamic： 1234void func1(dynamic object)&#123; object.toString(); //(1) object.a(); //(2)&#125; 此时编译器则可以编译运行。 为什么呢？前面已经说了，Object是所有类的基类，而dynamic代表任意未知类型。两者功能基本一样，但是当使用dynamic来声明参数时，你可以通过该参数调用任意函数或变量，而编译器不会报任何异常。因为dynamic修饰的变量在编译器眼中看来，它是属于未知的，编译器不知道这个变量是否真的有这个函数或者变量，所以编译器选择闭嘴。 所以什么时候应该显示声明参数为dynamic呢？比如说我有一个类ClassA和ClassB，它们是两个没有任何关系的类，但是它们有两个共同的函数a，那么函数func1就能接受ClassA和ClassB的实例并且在内部调用函数a，而编译器不会对此报错。 但是官方也说到，最好还是不要用这种方式，dynamic应该尽可能不用，因为它不会被编译器检查，这样会导致程序不安全，程序员看着也很难猜测这种参数是什么类型。毕竟动态语言太过于“动态”就很难看了。 值得一提，Dart的静态检查和动态检查都很优秀，语言虽然是动态的，但是写起来跟静态强类型的语言相差不大。 var很多语言都有var关键字，作用基本都一样，表示类型为动态推断类型，编译器会将var声明的东西根据赋值反推类型。比如： 12var p1 = 1;var p2 = \"2\"; 在IDE中，这样在IDE中，能实时看到p1的static type为int，p2的static type为String。通过打印各自的runtimeType，也能看到和上述static type相似。 接下来有一点就有点意思了。如果我这样写： 123var p3; //(1)p3 = 1; //(2)p3 = \"2\"; //(3) 如果这样写，是可以编译、运行的（我目前的版本为Dart VM Version: 2.0.0-dev.54.0，往后的版本就不好说了）。 因为在（1）中，p3被动态推断为dynamic类型，所以在（2）中p3可以赋值为int，在（3）中可以赋值为String。在IDE中可以看到p3的static type为dynamic，而分别打印（2）、（3）时的runtimeType则分别为int和String。 所以，使用var最好是及时赋值，让编译器可以推断出实际类型，否则推断出类型为dynamic后，往后调用可能会出现不安全的情况。 num所有数字类型都继承自num，而数字类型也就只有2个： int - 表示任意长度的整数 double - 表示双精度浮点数 Dart中没有float、long、short、byte这些类型，统统用以上两种表示。 String字符串类型。顺带一提Dart也没有char类型。 Dart中的字符串支持+操作符，即： 12String str1 = \"abc\";String str2 = str1 + \"d\"; //str2 = \"abcd\" String支持在字符串中插入变量和代码，如： 123String str1 = \"abc\";String str2 = \"$str1\"; //str2 = \"abc\"String str3 = \"$&#123;str1.compareTo(str2)&#125;\" //str3 = \"true\"; 字符串前面加r，可以避免转义作用，声明该字符串为原始字符串： 12String str1 = \"\\n\";//输出换行String str2 = r\"\\n\";//输出\"\\n\" bool布尔类型，这个不用多说。 这些就是常用的基本类型，剩下的容器类型迟些再说。 const和finalconst和final都用于修饰不可修改的常量，唯一的不同点是在其声明时： const声明的常量是编译时常量，即编译时就需要确定值，所以声明时需要指定明确的值。 final声明的常量是运行时常量，即实际运行时才确定常量的值。 例如： 12345const int p1 = 1; //(1)final int p2 = 2; //(2)const int p3 = p1.compareTo(p2); //(3)final int p4 = p1.compareTo(p2); //(4) 在上面的代码中，（1）、（2）、（4）都可以编译运行，（3）在编译时则会提示错误。","link":"/article/dev/53564420.html"},{"title":"The ABC of Dart Part 3 - 类","text":"前面说到Dart中一切皆为对象。而所有对象都是类的实例，并且所有类都为Object的子类。 和其他语言一样，类也是用class关键字作为声明。 123class TestClass&#123; ...&#125; 构造函数Dart具有构造函数，跟C++不一样，没有析构函数。 1234class TestClass&#123; TestClass()&#123; &#125;&#125; 上述代码是标准写法。如果没有显示声明构造函数，类默认有一个无参数的构造函数。另外，Dart针对构造函数中没有内容的情况时提供了一种简写，比如上述代码可以简写如下： 123class TestClass&#123; TestClass(); //简写&#125; 没有函数重载！Dart中没有函数重载功能，当在同一个类中定义了一个名为func的函数后，后面不能再定义一个名字相同、但返回类型和参数类型不同的函数。 同样的，因为没有函数重载，构造函数也不存在重载，即当一个类中定义了一个构造函数后，就无法再定义一个相同名字、但构造不同的函数。 1234567class TestClass&#123; TestClass(); TestClass(int i)&#123; //TODO &#125;&#125; 如上述代码，IDE会提示错误，不允许编译。 命名构造函数那么，如果一个类确实需要多个构造函数时该怎么做呢？Dart提供了命名构造函数，即构造函数可以定义不同的名字，通过.来实现，如： 1234567class TestClass&#123; TestClass(); //默认的构造函数 TestClass.second(int i)&#123; //自定义命名的构造函数 //TODO &#125;&#125; 通过命名构造函数，可以实现如其他语言中类的构造函数重载的功能。 生成对象生成一个类的实例对象，通过new关键字实现，如下： 12var obj1 = new TestClass(); //默认的构造函数var obj2 = new TestClass.second(1); //自定义命名的构造函数 构造函数传参Dart中的类和Java一样，通过this关键字指向实例自身，因此标准的构造函数传参和Java一致： 1234567class TestClass&#123; int param; TestClass(int param)&#123; this.param = param; &#125;&#125; 同时，Dart在传参上也提供了简写，也是通过this关键字实现的： 1234567class TestClass&#123; int param1, param2; TestClass(this.param1, this.param2)&#123; //TODO &#125;&#125; 如上述代码，这样调用构造函数将自动把值传递给类的变量。如果构造函数只用于传递值，而不需要在里面做其他逻辑，则可以这样简写： 12345class TestClass&#123; int param1, param2; TestClass(this.param1, this.param2);&#125; 值得一提的是，在构造函数中也可以使用可选参数来定义参数。 生成不可变的对象Dart中可以用const修饰构造函数，这样通过该构造函数构建出来的对象是不可变的对象，此类对象可以赋值给final或const修饰的常量。 12345678910111213141516class TestClass&#123; final int p1, p2; TestClass(this.p1, this.p2)&#123; //TODO &#125; const TestClass.second(this.p1, this.p2);&#125;//生成对象//const TestClass obj1 = new TestClass(1,2); //报错const TestClass obj1 = const TestClass.second(1,2); //(1)final TestClass obj2 = const TestClass.second(1,2); //(2)final TestClass obj3 = new TestClass(1,2); //(3)var obj4 = new TestClass.second(1,2); //(4) 如上，除了注释掉的那一行会报错的以外，(1)、(2)、(3)、(4)行都可以编译运行。其中，被const所修饰的常量，赋值时必须用const来生成对象，不能用new；反过来，final所修饰的对象，用const或者new来生成对象都可以。 需要注意的是，使用const修饰构造函数时，其对应的类中的所有成员变量都必须用final修饰，并且不允许有函数body（即大括号{}包裹的逻辑语句）。 同时，由于成员变量被final修饰，所以构造函数必须用简写的模式来给变量赋值。例如： 12345678class TestClass&#123; int p1; final int p2; TestClass(int a ,this.p2)&#123; p1 = a; &#125;&#125; 上述代码中，因为变量p2被修饰为final，所以必须用简写模式赋值。 Getter &amp; Setter在Dart中，类中的成员变量、成员函数不存在访问权限这个概念，像Java中的private、public之类的并不存在。 123456789class TestClass&#123; int p1; int p2;&#125;//调用var testClass = new TestClass();testClass.p1 = 1;print(testClass.p2); 如上述代码中，任何人只要生成了类的实例对象，就可以通过对象来访问、修改这个类的成员变量。但这里又和其他的语言有点不同——在Dart中，之所以可以直接调用、修改实例的变量，是因为在Dart中类的所有成员变量默认有其隐式的相同名字的Getter和Setter，如果变量被final或const修饰，那么只有Getter没有Setter。 如果要显式定义某个变量的Getter或者Setter，则分别需要用get和set关键字来实现： 123456789101112131415161718192021222324252627class TestClass&#123; int p1; int p2; //int get p1 =&gt; p1;//报错 //set p1(int i) =&gt; p1 = i;//报错 int get myP1 =&gt; p1; int get myP2&#123; return p2; &#125; set myP1(int i) =&gt; p1 = i; set myP2(int i)&#123; p2 = i; &#125;&#125;//调用var testClass = new TestClass();testClass.myP1 = 1; //调用Setter方法myP1testClass.myP2 = 2; //调用Setter方法myP2print(testClass.myP1); //调用Getter方法myP1，打印1print(testClass.myP2); //调用Getter方法myP2，打印2 如上述代码，Getter和Setter的方法名可以相同。注意get修饰的Getter方法不能有()。set修饰的Setter方法后面带有()，但调用时不能用testClass.myP1(1)这种方式，而是用=来调用Setter方法。 前面说到，每个成员变量有其隐式的Getter和Setter，所以当我们自定义Getter、Setter时，命名不能用和成员变量一样的名字。 extends &amp; implements类的继承通过extends关键字来实现，基本实现和操作跟Java大致相同。 12345678910111213141516class BaseClass&#123; void func1()&#123; //TODO &#125; void func2()&#123; //TODO &#125;&#125;class TestClass extends BaseClass&#123; @override void func1()&#123; super.func1(); &#125;&#125; 如上，TestClass集成了BaseClass，因此可以选择性地改写BaseClass的方法。 而实现接口则通过implements关键字实现，与Java不同的是dart没有interface这个关键字，因为每一个类都是一个隐式接口。以上面的BaseClass为例： 123456789class TestClass2 implements BaseClass&#123; @override void func1()&#123; &#125; @override void func2()&#123; &#125;&#125; TestClass2通过implements实现了BaseClass内定义的方法func1()、func2()，虽然BaseClass在func1()、func2()里都有定义内容，但通过implements实现后，TestClass2并不会像extends一样默认执行BaseClass的方法。 抽象类抽象类通过abstract关键字修饰类： 123456789101112131415abstract class BaseClass&#123; void func();&#125;class TestClass extends BaseClass&#123; @override void func()&#123; &#125;&#125;class TestClass2 implements BaseClass&#123; @override void func()&#123; &#125;&#125; 可以看出，抽象类在继承和实现接口上并没有什么区别，都是强制要求实现抽象类中定义的函数。 和Java不同，dart只有抽象类，没有抽象方法。 mixin(混合)我们知道，实现接口时可以implements多个接口，每个接口用逗号隔开： 123class TestClass implements BaseClass1,BaseClass2&#123; ...&#125; 而继承只能继承一个类。某些时候，可能我们希望能继承多个类，不同的方法用不同类的实现方式——这时候，就可以使用dart提供的mixin(混合)模式。 mixin通过with关键字来实现。举个例子，现在分别有两个类ClassA和ClassB，通过这两个类组合成一个新的类ClassC，则表现为： ClassC = ClassA with ClassB 假设ClassA中所有方法的集合为\\(F_{A}\\)，ClassB中所有方法的集合为\\(F_{B}\\)，ClassC中所有方法的集合为\\(F_{C}\\)，则可理解为： $$F_{C}=F_{B} \\cup (F_{A}-F_{B})$$ 即ClassC中的所有方法为ClassA和ClassB的方法的集合，如果ClassA和ClassB中有重复的方法，则取ClassB的实现： 1234567891011121314151617181920212223class ClassA&#123; void func1()&#123; print(\"ClassA func1\"); &#125; void func2()&#123; print(\"ClassA func2\"); &#125;&#125;class ClassB&#123; void func1()&#123; print(\"ClassB func1\"); &#125;&#125;class ClassC = ClassA with ClassB;void main()&#123; ClassC classC = new ClassC(); classC.func1();//输出ClassB func1 classC.func2();//输出ClassA func2&#125; with关键字也可以通过逗号混合多个类。例如，目前分别有ClassA、ClassB、ClassC三个类，将该三个类组合成一个新类ClassD： ClassD = ClassA with ClassB,ClassC 这就相当于按顺序调用with： ClassD = (ClassA with ClassB) with ClassC 例子如下： 1234567891011121314151617181920212223242526272829303132333435363738class ClassA&#123; void func1()&#123; print(\"ClassA func1\"); &#125; void func2()&#123; print(\"ClassA func2\"); &#125; void func3()&#123; print(\"ClassA func3\"); &#125;&#125;class ClassB&#123; void func1()&#123; print(\"ClassB func1\"); &#125; void func2()&#123; print(\"ClassB func2\"); &#125;&#125;class ClassC&#123; void func1()&#123; print(\"ClassC func1\"); &#125;&#125;class ClassD = ClassA with ClassB,ClassC;void main()&#123; ClassD classD = new ClassD(); classD.func1();//输出ClassC func1 classD.func2();//输出ClassB func2 classD.func3();//输出ClassA func3&#125; 工厂构造函数使用factory修饰构造函数，具体意义不多说了，网上给出的例子都是方便调用者可以使用同一个对象，并不是单纯意义上的工厂设计模式。","link":"/article/dev/bd58250c.html"},{"title":"The ABC of Dart Part 2 - 函数","text":"函数的写法跟其他语言基本大同小异，如下： 123int func1(String str)&#123; return int.parse(str);&#125; 在以上的函数func1中，声明了返回值为int类型的对象，函数参数为String，这是一种标准写法。 函数的简写动态脚本语言，或者函数式编程语言，特点之一就是函数可以简写，如： 12345678910111213int func1(String str)&#123; return 1;&#125;func2(String str)&#123; return 1;&#125;func3(str)&#123; return 1;&#125;func4(str) =&gt; 1; 因为在Dart中类型是可选的，所以像函数func2缺省声明返回值类型、函数func3缺省声明参数类型的写法都可以，在这种情况下，编译器默认将缺省声明类型的都声明为dynamic。不过个人建议还是不要这样省略，dynamic会让程序员感到困惑。 函数func4是Dart提供的一种新的写法，类似于Java的lambda，当函数内只有一行语句时，可以用=&gt;来简写，即func4代表的函数类型和func3、func2一样。 函数对象 - Function前面说过，Dart中一切皆为对象，函数也不例外，它的对象类型为Function。 12345void func1(String str)&#123; //TODO...&#125;print(func1 is Function);// 打印true 像这样，通过Dart的is关键字用来判断类型，可知函数func1的类型就是Function。 但就我的理解，Function对于函数而言，就是一个基类。所有函数都的类型都基于Function，而每一种函数都有其特定的类型。 比如，上述的函数func1，可以用对象的概念套进去，即func1的基本类型是Function，实际类型是(String) -&gt; void，而fucn1则是这个实际类型的实例的名称。 我认为，需要先理解这个概念，才能明白为何把函数称为第一公民，为何认为一切皆对象。不仅仅是Dart这么语言，目前大多的动态语言、函数式语言都是类似的这种设定。 闭包函数作为一种对象，既然有匿名对象，也就有匿名函数，如下： 12345678//(1)(String name) =&gt; \"Hello $name\";//(2)(name)&#123;print(\"Hello $name\");return 1;&#125; 像(1)、(2)这种把函数名、返回类型缺省的写法就是匿名函数。得益于函数也是对象这个概念，匿名函数这种写法才能实现。 以(1)为例子，匿名函数的写法舍去了函数名和返回类型，编译器会自动推断这段函数的返回类型，同时这段函数的实际类型为(String) -&gt; String。 如果这样一看，就像把一段封装好的逻辑包裹在函数这个对象的体内，因为函数自为对象，所以这个函数具备传递性，它可以被任意拿去调用，而不再像面向对象的语言一样，函数方法依附于实体类，这里就引申出函数式编程最重要的概念：闭包。 函数作为一种对象，因此可以作为返回值，也可以作为参数被传递。关于闭包的概念，寥寥几句无法说得清除。这里给出一种比较思路：比如在Java中，函数方法是作为一个对象的成员，我们要调用一个函数方法，调用它的这段逻辑，必须先传递对象，获取对象；反过来在Dart中，我们也是需要传递对象、获取对象，只是函数此时变成了一个对象，实际上我们依然在跟对象打交道，只是函数对象的出现使得一段逻辑本身就能被打包成一个可传递可获取的对象。 但是闭包不仅限于表示一段函数，而是一段包含了上下文环境的函数，这里还是不多说，只用一段代码表示一下 1234var func = (int a)&#123; int b = 4; return (int c) =&gt; a - b - c;&#125;(1); 在这段代码中，这段代码先定义了一段匿名函数，我们把该匿名函数叫做f1，f1的类型为(int) -&gt; Function，表示返回值是函数。然后我在匿名函数f1后面写上(1)，表示调用f1，传入参数1。f1的内部声明了一个变量int b = 4，并返回了一段匿名函数，我们把这段匿名函数叫做f2，f2的类型为(int) -&gt; int。因为我们调用了f1，所以立刻返回了f2并赋值给声明为动态推断类型的变量func，所以func的类型就是Function，它的实际类型就是f2这段函数。 注意这里的f2函数，其实携带着它的上下文环境——即int b = 4这个变量的。关于这个上下文环境不再多说，此处只作为一个例子。而从这个例子也可以得知，闭包的内存消耗比一般的对象可能要大，因为它包含了上下文环境。 回到开头所说的匿名函数，因为它缺省了函数名，所以在声明一段匿名函数时，必须立刻给它赋值，或者立刻执行它。所以开头的代码(1)、(2)应该这样写： 12345678//(1)var func1 = (String name) =&gt; \"Hello $name\";//(2)(name)&#123;print(\"Hello $name\");return 1;&#125;(\"world\"); 注意： 将匿名函数赋值给某个变量时，需要将变量声明为var或Function。 匿名函数无法在函数外或类外立刻调用，只能声明。 typedeftypedef是Dart中的关键字。我的理解是用于定义函数类型，即将一种函数类型定义成一种对象；而网上的说法是typedef用于定义函数类型的别名。 1typedef int Compare(Object a, Object b); 在上述代码中，将(Object, Object) -&gt; int这种函数的实际类型给予了一个具体的名称Compare，这意味着，一旦任何一个函数的实际类型是(Object, Object) -&gt; int，则这个函数的实际类型等同于Compare。例如： 12345int compareFunc(Object a1, Object b1)&#123; return 0;&#125;print(compareFunc is Compare);//打印true 上述代码中的函数compareFunc的实际类型为(Object, Object) -&gt; int，所以用is来与Compare作判断的结果为true。 之前说过Function代表函数类型，所以作为一种类型，也是可以定义为函数的返回值类型和参数类型。如： 123Function getFunc(int a)&#123; return (int b) =&gt; b - a;&#125; 因为用typedef定义了一段函数类型的名字，所以可以用该名字作为返回值类型或参数类型，如： 12345Compare getFunc(int i)&#123; return (Object a,Object b)&#123; return i; &#125;;&#125; 可选参数可选参数是Dart在函数上增加的新特性，作用如名字一样，当在函数中声明了可选参数，在调用该函数时我们可以选择是否传递该可选参数。 可选参数有两种： 命名可选参数命名可选参数用大括号{}包围，默认值可用:或=来赋值。 12345678void func(int a, &#123;int b:3, c, d&#125;)&#123; //TODO&#125;//调用func(1); //(1)func(1,b:4); //(2)func(1,c:5); //(2) 上述代码中，我们定义了func函数，函数参数中必须要传的是a，剩下的是可传可不传的参数b、c、d，我们用大括号包围。其中某些可选参数我们想要有一个默认值，可以在声明时就用:或者=来赋值，如参数b。 在调用时，我们可以只传必须要传的参数，如(1)。如果我们想要传入某些参数，比如我们要传入参数b，则可以如(2)一样调用，注意因为是命名可选参数，所以在传入可选参数时必须声明传给哪个参数。 位置可选参数位置可选参数用方括号[]包围，默认值用=来赋值。 1234567void func(int a , [int b = 3, c, d])&#123; //TODO&#125;//调用func(1); //(1)func(1,2,3); //(2) 上述代码中，我们定义了func函数，函数参数中必须要传的是a，剩下的是可传可不传的参数b、c、d，我们用中括号包围。其中某些可选参数我们想要有一个默认值，可以在声明时就用=来赋值，如参数b。 表面上，位置可选参数和命名可选参数区别不大。实际上它们的区别在调用时的传参：命名可选参数传参时必须声明传给哪个参数，而位置可选参数则是按顺序来传值的。在(1)中只传必须参数时和命名可选参数一样。但在(2)中可以看到，传参时不需要声明参数名，当我们传入的参数为1、2、3时，函数将分别把参数赋值到a、b、c中。","link":"/article/dev/ca5f159a.html"},{"title":"The ABC of Dart Part 4 - 集合","text":"Dart中提供的集合容器分别是我们常见的List、Map、Set，但它也只有这三种类型的集合，并不像其他语言会细分到ArrayList、LinkedList之类的。 List(列表 &amp; 数组)在Dart中没有数组的概念，取而代之的是用List来代替数组的功能。 所以在List的构造函数中，有一个构造函数是传入长度来创建对象，该List对象为固定长度的列表，无法改变长度。 123456var list1 = new List();list1.length = 3;list1.length = 5;var list2 = new List(3);list2.length = 5;//error 如上，通过List()创建的列表list1可以动态更改长度，而通过List(int length)创建的列表list2则无法更改长度。 创建一个List也可以通过简略的方式实现： 1var list = [1, 2, 3]; 如上，可以通过现成数据创建List，创建方式为用中括号[]加上数据，数据之间用逗号隔开。 前面也说了，List代替了数组功能，因此它也实现了数组的功能： 123var list = [1, 2, 3];print(list[0]);//打印1list[1] = 4; 如上，可以通过使用数组的形式来调用List中的子项。 最主要的是以上几点，其他的像List的其他构造函数、其他使用方法，在源代码中的list.dart中描述得很详细了，可以对照着使用。 MapMap的初始化也和其他类相似，当然它也有简略的方式： 1234var map = &#123; \"a\": 1, \"b\": 2&#125; 如上，可以用大括号{}包住已有数据，其中的数据为一个个的键值对，每个键值对用冒号:分割，冒号前的为key，冒号后的为value。 Map的使用方式也和List相同： 1234567var map = &#123; \"a\": 1, \"b\": 2&#125;print(map[\"a\"]);map[\"b\"] = 3; 和List不同的是，中括号中的是Map里的key，而List是对应的序号。 SetSet是无序的，并且内部元素在Set中是唯一的。因此，Set无法像List一样通过序号来访问数据；还有一点，Set没有像List那样的简略的构造方式： 12var set1 = new Set();var set2 = new Set.from([1, 2, 3]); 注：from构造函数以上三个集合容器都有 要访问Set中的任意一个值，则需要通过elementAt()函数： 123var set = new Set.from([\"A\", \"B\", \"C\"]);print(set.elementAt(1));//打印B","link":"/article/dev/a2cf4cff.html"},{"title":"The ABC of Dart Part 5 - 操作符重载","text":"Dart可以像C语言一样重载部分操作符。支持重载的操作符有： &lt; + ^ [] &gt; / &amp; []= &lt;= ~/ &lt;&lt; ~ &gt;= * &gt;&gt; == – % 重载通过operator关键字实现： 123456789101112131415161718class Point&#123; int x; int y; Point(this.x, this.y); //重载加号运算符 Point operator +(Point point)&#123; return new Point(x + point.x, y + point.y); &#125;&#125;void main()&#123; Point p1 = new Point(1,2); Point p2 = new Point(3,4); print((p1 + p2).x);//打印4 print((p1 + p2).y);//打印6&#125;","link":"/article/dev/543b8039.html"},{"title":"The ABC of Dart Part 6 - 库类的引用","text":"Dart中除了最基本的类型对象外，还提供了很多不同功能的库或类，比如一些异步操作、IO操作等等，这些都被一一封装到Dart的SDK中，由一个个独立的.dart文件承载着。 举个例子，在Java中，如果要使用某个类的功能，需要先通过import把该类引用进来。同样的，Dart也需要这种操作。 目前我使用的Android Studio 3.1.3，比较不好的一点是写Dart时不能像Java一样自动引用对应的库。 Pub包管理器了解库类的引用前，先学习一下Dart中的Pub包管理器。 Pub有点像Android项目中的Gradle——Gradle管理下的Android项目，我们用build.gradle来管理项目中的引用和其他配置；同样的，Dart也有pubspec.yaml来管理引用。 一般地，一个Dart项目的根目录下，包含有lib文件夹和pubspec.yaml文件。该文件包含了一个包的元数据，例如包的名称等。所以一个Dart项目也是一个包。 举个例子，一个最简单的pubspec.yaml内容如下： 1234name: testdeppendencies: cupertino_icons: ^0.1.2 name表示该包的名称，而deppendencies下的每一项则表示该包的引用。上述内容就表示了一个名叫test的包，这个包引用了一个名为cupertino_icons，版本号为0.1.2的包。 这里的版本号写法为^0.1.2，表示该版本号的约束为&gt;=0.1.2 &lt;0.2.0，这种写法为Caret语法，关于这点不作详细描述。 关于更多的有关pub的操作（例如配置项目资源、使用pub的命令行命令等）就不再阐述，此类操作可以等需要用到时再查找。 importDart中的import用法和Java基本相同，不同的是import后缀的引用路径： 1234567891011121314//\"dart:\"前缀表示Dart的标准库import 'dart:async';//同文件夹下的dartimport 'lib1.dart';//同路径下的其他文件中的dartimport 'lib2/lib2.dart';//绝对路径import '../lib3/lib3.dart';//通过包名+路径import 'package:test/lib1.dart'; 其中通过包命+路径的引用方式，结合上述的Pub，可知我在本项目中的pubspec.yaml里引用了一个名为test的包，则我可以在项目内的.dart文件里通过前缀package:加上包名+库类在该包内的路径来引用相应的库类。 命名冲突很多时候，我们引用的库类可能存在名称相同的情况，比如： 12345import 'p1/lib1.dart';import 'p2/lib2.dart';//编译器提示异常MyClass myClass = new MyClass(); 如上，我在lib1.dart和lib2.dart中都定义了一个名为MyClass的类，当我在引用处使用MyClass时，编译器提示我这个类在lib1.dart和lib2.dart都有定义，因此无法编译。 针对这种情况，可以使用as关键字，对某个引用声明其命名空间： 12345import 'p1/lib1.dart' as lib1;import 'p2/lib2.dart' as lib2;lib1.MyClass myClass1 = new lib1.MyClass();lib2.MyClass myClass2 = new lib2.MyClass(); 如上，通过声明不同的命名空间，则可以在调用时通过对应的命名空间即可。 部分引用有时候，我们可能只希望引用一个.dart文件中的某些库类，而不是引用其全部内容，则可以通过关键字show和hide来实现。 顾名思义，show表示只引用一个文件中的指定类；而hide则表示除指定类外其他类都引用。它们都可以通过逗号指定多个类： 12import 'p1/lib1.dart' show MyClass1,MyClass2;import 'p2/lib2.dart' hide MyClass3; librarylibrary关键字可以定义一个.dart文件（即一个库）的名字，但不影响库的引用，因为引用都是通过文件路径。 之所以要定义名字，是因为这个要配合part、part of关键字来使用。 例如，当我要维护一个库math，这个库包含项目需要的所有数学方法，比如加减乘除，那么这个库可以通过part来将不同的功能放到不同的.dart文件中，达到将库分散、细化粒度的效果。 123456library math;part 'plus.dart';part 'minus.dart';part 'multiply.dart';part 'divide.part'; 如上，我可以创建一个math.dart文件，这个文件路径在lib/math文件夹下。math.dart文件内部只有上述内容，因为具体实现功能都分散给各.dart文件来实现。 相应地，part修饰的各个文件内部，都需要通过part of来声明自身属于哪个库： 1part of math; 所以在plus.dart等四个文件中，开头都需要通过上述代码声明自己属于math这个库中。 关于library、part、part of，可以再看看Dart的SDK，里面的很多库都是通过这种方式实现的。 exportexport的使用方式和import相同，但是意义却不一样。它表示在一个库中导出另一个库，这样当第三个库引用第一个库时，也能引用到第二个库的内容。 例如，我现在有lib1.dart、lib2.dart、lib3.dart三个文件，其中lib1.dart中的内容为： 12import 'lib2.dart';export 'lib2.dart'; 然后在lib3.dart中： 1import 'lib1.dart'; 这样，即使lib3.dart中没有导入lib2.dart，也可以用到lib2.dart内的内容。 关于export的实际应用可以看一下这篇文章：organizing-a-library-package。","link":"/article/dev/cd32d183.html"},{"title":"The ABC of Dart Part 7 - 异步","text":"Dart中没有线程这种概念，或者说对线程进行了包装，调用者无法对线程进行直接的操作。所以Dart为异步操作提供了一些对应的API和关键字，分别有： async和await关键字 Async*、sync*、yield*关键字和Stream的API Future的API 细分下来还是挺多内容的，尤其像Stream这种流式操作，网上相关的资料都叙述得不够详细。 async和awaitasync和await组合可以实现异步功能，并且使得代码看上去像是同步流程一样（网上说的）。 首先举个例子： 12345678import 'dart:io';import 'dart:core';void main() &#123; print(new DateTime.now());// (1) sleep(new Duration(seconds: 1)); print(new DateTime.now());// (2)&#125; 如上，最终会先打印(1)，间隔1秒后打印(2)，打印如下： 122018-08-13 15:40:13.5852712018-08-13 15:40:14.588507 其中DateTime来自包dart:core，而sleep方法来自包date:io。 我们暂且把main()函数运行的环境称为“线程”。当调用sleep时，Dart的主线程会被阻塞，直到sleep结束才接着进行下一步操作，这些现象都跟其他语言相同。 但是我们可以通过将耗时操作异步执行，达到不阻塞主线程： 1234567891011121314import 'dart:io';import 'dart:core';callSleep() async &#123; print(\"async start:$&#123;new DateTime.now().toString()&#125;\"); sleep(new Duration(seconds: 1)); print(\"async end:$&#123;new DateTime.now().toString()&#125;\");&#125;void main() &#123; print(\"main start:$&#123;new DateTime.now()&#125;\"); callSleep(); print(\"main end:$&#123;new DateTime.now()&#125;\");&#125; 打印结果： 1234main start:2018-08-13 17:28:31.456818main end:2018-08-13 17:28:31.462557async start:2018-08-13 17:28:31.462995async end:2018-08-13 17:28:32.463558 可以看到，主线程并没有被阻塞，异步操作则被sleep阻塞，但不会影响到主线程。 从上述代码中可以看出，async关键字用于修饰函数。当一个函数被async修饰时，该函数将返回一个future对象。被async修饰的函数，被调用时将运行在异步环境。 async可以单独使用（修饰函数），但await则不行。await用于修饰返回future的函数，并且必须在带有async的函数内使用，它的作用为等待一个异步函数执行完毕。 例如，我有如下代码： 1234567891011121314151617181920import 'dart:io';import 'dart:core';callSleep() async &#123; print(\"async start:$&#123;new DateTime.now().toString()&#125;\"); callSleep2(); print(\"async end:$&#123;new DateTime.now().toString()&#125;\");&#125;callSleep2() async &#123; print(\"callSleep2 start:$&#123;new DateTime.now().toString()&#125;\"); sleep(new Duration(seconds: 1)); print(\"callSleep2 start:$&#123;new DateTime.now().toString()&#125;\");&#125;void main() &#123; print(\"main start:$&#123;new DateTime.now()&#125;\"); callSleep(); print(\"main end:$&#123;new DateTime.now()&#125;\");&#125; 打印如下： 123456main start:2018-08-13 18:22:04.529513main end:2018-08-13 18:22:04.534770async start:2018-08-13 18:22:04.535263async end:2018-08-13 18:22:04.535454callSleep2 start:2018-08-13 18:22:04.537200callSleep2 start:2018-08-13 18:22:05.537942 可以看到callSleep2是在callSleep运行之后才运行的。如果在callSleep中对callSleep2加入await： 1234567891011121314151617181920import 'dart:io';import 'dart:core';callSleep() async &#123; print(\"async start:$&#123;new DateTime.now().toString()&#125;\"); await callSleep2(); print(\"async end:$&#123;new DateTime.now().toString()&#125;\");&#125;callSleep2() async &#123; print(\"callSleep2 start:$&#123;new DateTime.now().toString()&#125;\"); sleep(new Duration(seconds: 1)); print(\"callSleep2 start:$&#123;new DateTime.now().toString()&#125;\");&#125;void main() &#123; print(\"main start:$&#123;new DateTime.now()&#125;\"); callSleep(); print(\"main end:$&#123;new DateTime.now()&#125;\");&#125; 打印如下： 123456main start:2018-08-13 18:23:16.099116main end:2018-08-13 18:23:16.104197async start:2018-08-13 18:23:16.104623callSleep2 start:2018-08-13 18:23:16.106389callSleep2 start:2018-08-13 18:23:17.106978async end:2018-08-13 18:23:17.108346 可以看出打印不同了。callSleep需要等到callSleep2的异步执行完毕之后才能继续执行。 Future API事实上，Dart中的异步执行操作都是依靠Future来实现的，即便是上述的async和await关键字，最终操作的依然是Future。 Future所代表的含义，就是在调用时调用本身立即返回，并在稍后的某个时候执行完成时再获得返回结果。 Future的定义在SDK的async包中，可以看出有好几种构造函数： Future(FutureOr computation()) Future.microtask(FutureOr computation()) Future.sync(FutureOr computation()) Future.value([FutureOr value]) Future.error(Object error, [StackTrace stackTrace]) Future.delayed(Duration duration, [FutureOr computation()]) 其中最常用的构造函数是1和6。事实上，如果接触过RxJava，对于Future的使用方式会容易理解一些，因为基本的构造、链式调用等一系列方法都非常相似。 例如： 12345678910111213141516import 'dart:async';import 'dart:io';import 'dart:core';Future&lt;int&gt; future = new Future(() &#123; int i = 1; print(\"future start:$i, time:$&#123;new DateTime.now()&#125;\"); sleep(new Duration(seconds: 1)); return ++i;&#125;);void main() &#123; print(\"main start:$&#123;new DateTime.now()&#125;\"); future.then((i) =&gt; print(\"future end:$i, time:$&#123;new DateTime.now()&#125;\")); print(\"main end:$&#123;new DateTime.now()&#125;\");&#125; 打印如下：1234main start:2018-08-16 15:31:15.543445main end:2018-08-16 15:31:15.550062future start:1, time:2018-08-16 15:31:15.551202future end:2, time:2018-08-16 15:31:16.554641 Future(FutureOr&lt;T&gt; computation())这个构造函数相当于RxJava中的Observable.create()方法，将需要异步执行的操作包裹在函数，将该函数作为参数传递给Future。 Future在main()外初始化时不会立即执行，直到被main()调用时则开始执行，这一点和RxJava不同，RxJava必须调用subscribe()才开始调用。 如果需要在Future执行完毕后获取异步执行的结果来进行一些操作，可以使用then()来执行，这一点跟RxJava的subscribe()操作相同。 同时，then具有可选参数Function onError，可以用来处理Future在执行过程中出现异常的情况。 123456789101112131415161718import 'dart:async';import 'dart:io';import 'dart:core';Future&lt;int&gt; future = new Future(() &#123; int i = 1; print(\"future start:$i, time:$&#123;new DateTime.now()&#125;\"); sleep(new Duration(seconds: 1)); throw new ArgumentError(\"Custom Error\"); return ++i;&#125;);void main() &#123; print(\"main start:$&#123;new DateTime.now()&#125;\"); future.then((i) =&gt; print(\"future end:$i, time:$&#123;new DateTime.now()&#125;\"), onError: (e) =&gt; print(\"catch error:$e\")); print(\"main end:$&#123;new DateTime.now()&#125;\");&#125; 打印： 1234main start:2018-08-16 15:41:03.173648main end:2018-08-16 15:41:03.180109future start:1, time:2018-08-16 15:41:03.181231catch error:Invalid argument(s): Custom Error 可以看到，如果Future内部出现了异常，将不会返回结果到then()中的第一个函数，而是将异常返回给第二个onError函数。 then()的链式调用有时候我们可能需要在Future之后执行多步操作，并且每一步操作都依赖于上一步的结果。对此我们当然可以把相关操作写在同一个then()里面。但是Dart提供了对应的链式调用，使得我们可以用多个then()将不同的操作串联起来： 12345678910111213141516171819202122232425import 'dart:async';import 'dart:io';import 'dart:core';Future&lt;int&gt; future = new Future(() &#123; int i = 1; print(\"future start:$i, time:$&#123;new DateTime.now()&#125;\"); sleep(new Duration(seconds: 1)); return ++i;&#125;);void main() &#123; print(\"main start:$&#123;new DateTime.now()&#125;\"); future.then((i) &#123; print(\"first then:$i, time:$&#123;new DateTime.now()&#125;\"); return ++i; &#125;).then((i) &#123; print(\"second then:$i, time:$&#123;new DateTime.now()&#125;\"); return ++i; &#125;).then((i) &#123; print(\"third then:$i, time:$&#123;new DateTime.now()&#125;\"); return ++i; &#125;); print(\"main end:$&#123;new DateTime.now()&#125;\");&#125; 打印： 123456main start:2018-08-16 15:53:53.024344main end:2018-08-16 15:53:53.030724future start:1, time:2018-08-16 15:53:53.031873first then:2, time:2018-08-16 15:53:54.034334second then:3, time:2018-08-16 15:53:54.034514third then:4, time:2018-08-16 15:53:54.034651 我们在then()操作中可以将结果返回给下一个then()，并且参数类型不限定于Future返回的类型。 Future还有许多API，可以配合链式调用随意组合，具体的就不细说了。 函数生成器函数生成器是指利用惰性函数计算结果序列，以提升性能。就我的理解而言，类似于在函数内生成一个闭包，然后可以经过循环得到一系列结果，但结果并不是一次性返回，而是像一段数据流一样每次返回一个结果。 具体使用场景，自己还没想到，也许在一些需要递归或者循环调用返回的场景能用到吧。 同步生成器sync*使用sync*修饰函数时，函数将自动返回一个Iterable类型的实例，并可以根据该实例获取Iterator类型的迭代器。通过迭代器的函数moveNext()判断是否存在下一个值，通过current获取下一个值。 12345678910111213141516171819Iterable syncGenerator(int i) sync* &#123; print(\"syncGenerator start\"); for (int value = 0; value &lt; i; value++) &#123; print(\"syncGenerator yield\"); yield value; &#125; print(\"syncGenerator end\");&#125;void main() &#123; Iterator iterator = syncGenerator(3).iterator; print(\"start\"); while (iterator.moveNext()) &#123; print(\"start while\"); print(iterator.current); print(\"end while\"); &#125; print(\"end\");&#125; 如上，使用sync*制作生成器时，函数的内部需要通过yield关键字来声明需要输出的结果。yield表示生成，其实际操作类似于return，可用于声明结果或者是表达式。 上述输出如下： 12345678910111213141516startsyncGenerator startsyncGenerator yieldstart while0end whilesyncGenerator yieldstart while1end whilesyncGenerator yieldstart while2end whilesyncGenerator endend 可以看出，当调用生成器syncGenerator()时，生成器内部并未开始执行，直到调用moveNext()函数时，生成器开始运行，并进入循环，直到遇到yield所在行后，将在此暂停，并将结果返回到外部，注意此时生成器的内部环境依然保存着不变；当外部再次调用moveNext()时，生成器将由暂停变为继续运行，直到内部满足条件，不再运行到yield所在行，生成器运行结束。 当然，由于同步生成器返回的是Iterable，所以可以使用Dart提供的API进行链式调用： 1234567891011Iterable syncGenerator(int i) sync* &#123; print(\"syncGenerator start\"); for (int value = 0; value &lt; i; value++) &#123; yield value; &#125; print(\"syncGenerator end\");&#125;void main() &#123; syncGenerator(3).forEach((i) =&gt; print(i));&#125; 打印如下： 12345syncGenerator start012syncGenerator end 异步生成器async*异步生成器的原理和同步生成器基本相同，不同的是由于异步生成器运行在异步环境，因此返回的不是Iterable而是Stream。因此这里涉及到了Stream的相关操作和API。 Stream APIStream表示一个数据的流，关于流的概念和其他语言里的流的理解基本相同（比如Java8中的Stream），这里引用一下Java中对Stream的定义： Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。 Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。 而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。 12345678910111213Stream asyncGenerator(int i) async* &#123; print(\"asyncGenerator start\"); for (int value = 0; value &lt; i; value++) &#123; yield value; &#125; print(\"asyncGenerator end\");&#125;void main() &#123; print(\"start\"); asyncGenerator(3).listen((i) =&gt; print(i)); print(\"end\");&#125; 打印如下： 1234567startendasyncGenerator start012asyncGenerator end 可以看到由于异步执行，生成器的输出在main()执行完后才执行。 listen()方法相当于RxJava中的subscribe()方法，目的都是添加响应数据的方法，并且都会返回一个可以控制流的对象。通过listen()返回的控制对象类型为StreamSubscription。通过StreamSubscription可以方便地操控流： 1234567891011121314151617181920Stream asyncGenerator(int i) async* &#123; print(\"asyncGenerator start\"); for (int value = 0; value &lt; i; value++) &#123; yield value; &#125; print(\"asyncGenerator end\");&#125;void main() &#123; print(\"start\"); StreamSubscription subscription = asyncGenerator(3).listen( null, onDone: () =&gt; print(\"done\")); subscription.onData((i) &#123; print(i); if (i &gt;= 1) &#123; subscription.cancel().then((f) =&gt; print(\"cancel\")); &#125; &#125;); print(\"end\");&#125; 打印： 123456startendasyncGenerator start01cancel 可以看到cancel()操作会将异步生成器中断，不会使其运行到最后一步。","link":"/article/dev/ba35e115.html"},{"title":"The ABC of Dart Part 8 - 并发","text":"说到Dart中的并发，这里需要先介绍一下Dart中的异步机制，以下内容转自Dart异步任务与消息循环机制 Dart与消息循环机制翻译自https://www.dartlang.org/articles/event-loop/ 异步任务在Dart中随处可见，例如许多库的方法调用都会返回Future对象来实现异步处理，我们也可以注册Handler来响应一些事件，如：鼠标点击事件，I/O流结束和定时器到期。 这篇文章主要介绍了Dart中与异步任务相关的消息循环机制，阅读完这篇文章后相信你可写出更赞的异步执行代码。你也能学习到如何调度Future任务并且预测他们的执行顺序。 在阅读这篇文章之前，你最好先要了解一下基本的Future用法。 基本概念如果你写过一些关于UI的代码，你就应该熟悉消息循环和消息队列。有了他们才能保重UI的绘制操作和一些UI事件，如鼠标点击事件可以被一个一个的执行从而保证UI和UI事件的统一性。 消息循环和消息队列一个消息循环的职责就是不断从消息队列中取出消息并处理他们直到消息队列为空。 消息队列中的消息可能来自用户输入，文件I/O消息，定时器等。例如下图的消息队列就包含了定时器消息和用户输入消息。 上述的这些概念你可能已经驾轻就熟了，那接下来我们就讨论一下这些概念在Dart中是怎么表现的？ Dart的单线程执行当一个Dart的方法开始执行时，他会一直执行直至达到这个方法的退出点。换句话说Dart的方法是不会被其他Dart代码打断的。 Note:一个Dart的命令行应用可以通过创建isolates来达到并行运行的目的。isolates之间不会共享内存，它们就像几个运行在不同进程中的app，中能通过传递message来进行交流。出了明确指出运行在额外的isolates或者workers中的代码外，所有的应用代码都是运行在应用的main isolate中。要了解更多相关内容，可以查看https://www.dartlang.org/articles/event-loop/#use-isolates-or-workers-if-necessary 正如下图所示，当一个Dart应用开始的标志是它的main isolate执行了main方法。当main方法退出后，main isolate的线程就会去逐一处理消息队列中的消息。 事实上，上图是经过简化的流程。 Dart的消息循环和消息队列一个Dart应用有一个消息循环和两个消息队列– event队列和microtask队列。 event队列包含所有外来的事件：I/O，mouse events，drawing events，timers，isolate之间的message等。 microtask 队列在Dart中是必要的，因为有时候事件处理想要在稍后完成一些任务但又希望是在执行下一个事件消息之前。 event队列包含Dart和来自系统其它位置的事件。但microtask队列只包含来自当前isolate的内部代码。 正如下面的流程图，当main方法退出后，event循环就开始它的工作。首先它会以FIFO的顺序执行micro task，当所有micro task执行完后它会从event 队列中取事件并执行。如此反复，直到两个队列都为空。 注意：当事件循环正在处理micro task的时候。event队列会被堵塞。这时候app就无法进行UI绘制，响应鼠标事件和I/O等事件 虽然你可以预测任务执行的顺序，但你无法准确的预测到事件循环何时会处理你期望的任务。例如当你创建一个延时1s的任务，但在排在你之前的任务结束前事件循环是不会处理这个延时任务的，也就是或任务执行可能是大于1s的。 通过链接的方式指定任务顺序如果你的代码之间存在依赖，那么尽量让他们之间的依赖关系明确一点。明确的依赖关系可以很好的帮助其他开发者理解你的代码，并且可以让你的代码更稳定也更容易重构。 先来看看下面这段错误代码： 123// 这样写错误的原因就是没有明确体现出设置变量和使用变量之间的依赖关系future.then(...set an important variable...);Timer.run(() &#123;...use the important variable...&#125;); 正确的写法应该是： 123// 明确表现出了后者依赖前者设置的变量值future.then(...set an important variable...) .then((_) &#123;...use the important variable...&#125;); 为了表示明确的前后依赖关系，我们可以使用then()()来表明要使用变量就必须要等设置完这个变量。这里可以使用whenComplete()来代替then，它与then的不同点在于哪怕设置变量出现了异常也会被调用到。这个有点像java中的finally。 如果上面这个使用变量也要花费一段时间，那么可以考虑将其放入一个新的Future中： 12future.then(...set an important variable...) .then((_) &#123;new Future(() &#123;...use the important variable...&#125;)&#125;); 使用一个新的Future可以给事件循环一个机会先去处理列队中的其他事件。 怎么安排一个任务当你需要指定一些代码稍后运行的时候，你可以使用dart:async提供的两种方式： Future类，它可以向event队列的尾部添加一个事件。 使用顶级方法scheduleMicrotask()，它可以向microtask队列的尾部添加一个微任务。 使用合理的队列有可能的还是尽量使用Future来向event队列添加事件。使用event队列可以保持microtask队列的简短，以此减少microtask的过度使用导致event队列的堵塞。如果一个任务确实要在event队列的任何一个事件前完成，那么你应该尽量直接写在main方法中而不是使用这两个队列。如果你不能那么就用scheduleMicrotask来向microtask添加一个微任务。 Event队列使用new Future或者new Future.delayed()来向event队列中添加事件。 注意:你也可以使用Timer来安排任务，但是使用Timer的过程中如果出现异常，则会退出程序。这里推荐使用Future，它是构建在Timer之上并加入了更多的功能，比如检测任务是否完成和异常反馈。 立刻需要将任务加入event队列可以使用new Future 1234//向event队列中添加一个任务new Future(() &#123; //任务具体代码&#125;); 你也可以使用then或者whenComplete在Future结束后立刻执行某段代码。如下面这段代码在这个Future被执行后会立刻输出42： 123new Future(() =&gt; 21) .then((v) =&gt; v*2) .then((v) =&gt; print(v)); 如果要在一段时间后添加一个任务，可以使用new Future.delayed(): 1234// 一秒以后将任务添加至event队列new Future.delayed(const Duration(seconds:1), () &#123; //任务具体代码&#125;); 虽然上面这个例子中一秒后向event队列添加一个任务，但是这个任务想要被执行的话必须满足一下几点： main方法执行完毕 microtask队列为空 该任务前的任务全部执行完毕 所以该任务真正被执行可能是大于1秒后。 关于Future的有趣事实： 被添加到then()中的方法会在Future执行后立马执行(这方法没有被加入任何队列，只是被回调了)。 如果在then()调用之前Future就已经执行完毕了，那么会有一个任务被加入到microtask队列中。这个任务执行的就是被传入then的方法。 Future()和Future.delayed()构造方法并不会被立刻完成，他们会向event队列中添加一个任务。 3.1. Future.value()构造方法会在一个microtask中完成。 3.2. Future,sync()构造方法会立马执行其参数方法，并在microtask中完成。 Microtask队列： scheduleMicrotask()dart:async定义了一个顶级方法scheduleMicrotask() ，你可以这样使用： 123scheduleMicrotask(() &#123; // ...code goes here...&#125;); 如果有必要可以使用isolate或worker如果你想要完成一些重量级的任务，为了保证你应用可响应，你应该将任务添加到isolate或者worker中。isolate可能会运行在不同的进程或线程中.这取决于Dart的具体实现。 那一般情况下你应该使用多少个isolate来完成你的工作呢？通常情况下可以根据你的cpu的个数来决定。 但你也可以使用超过cpu个数的isolate，前提是你的app能有一个好的架构。让不同的isolate来分担不同的代码块运行，但这前提是你能保证这些isolate之间没有数据的共享。 测试一下你的理解程度目前为止你已经掌握了调度任务的基本知识，下面来测试一下你的理解程度。 问题1下面这段代码的输出是什么？ 1234567891011121314import 'dart:async';main() &#123; print('main #1 of 2'); scheduleMicrotask(() =&gt; print('microtask #1 of 2')); new Future.delayed(new Duration(seconds:1), () =&gt; print('future #1 (delayed)')); new Future(() =&gt; print('future #2 of 3')); new Future(() =&gt; print('future #3 of 3')); scheduleMicrotask(() =&gt; print('microtask #2 of 2')); print('main #2 of 2');&#125; 别急着看答案，自己在纸上写写答案呢？ 答案： 1234567main #1 of 2main #2 of 2microtask #1 of 2microtask #2 of 2future #2 of 3future #3 of 3future #1 (delayed) 上面的答案是否就是你所期望的呢？这段代码一共执行了三个分支： main()方法 microtask队列 event队列（先new Future后new Future.delayed） main方法中的普通代码都是同步执行的，所以肯定是main打印先全部打印出来，等main方法结束后会开始检查microtask中是否有任务，若有则执行，执行完继续检查microtask，直到microtask列队为空。所以接着打印的应该是microtask的打印。最后会去执行event队列。由于有一个使用的delay方法，所以它的打印应该是在最后的。 问题2下面这个问题相对有些复杂： 123456789101112131415161718192021222324252627import 'dart:async';main() &#123; print('main #1 of 2'); scheduleMicrotask(() =&gt; print('microtask #1 of 3')); new Future.delayed(new Duration(seconds:1), () =&gt; print('future #1 (delayed)')); new Future(() =&gt; print('future #2 of 4')) .then((_) =&gt; print('future #2a')) .then((_) &#123; print('future #2b'); scheduleMicrotask(() =&gt; print('microtask #0 (from future #2b)')); &#125;) .then((_) =&gt; print('future #2c')); scheduleMicrotask(() =&gt; print('microtask #2 of 3')); new Future(() =&gt; print('future #3 of 4')) .then((_) =&gt; new Future( () =&gt; print('future #3a (a new future)'))) .then((_) =&gt; print('future #3b')); new Future(() =&gt; print('future #4 of 4')); scheduleMicrotask(() =&gt; print('microtask #3 of 3')); print('main #2 of 2');&#125; 答案： 123456789101112131415main #1 of 2main #2 of 2microtask #1 of 3microtask #2 of 3microtask #3 of 3future #2 of 4future #2afuture #2bfuture #2cmicrotask #0 (from future #2b)future #3 of 4future #4 of 4future #3a (a new future)future #3bfuture #1 (delayed) 总结以下有几点关于dart的事件循环机制需要牢记于心： Dart事件循环执行两个队列里的事件：event队列和microtask队列。 event队列的事件来自dart（future，timer，isolate message等）和系统（用户输入，I/O等）。 目前为止，microtask队列的事件只来自dart。 事件循环会优先清空microtask队列，然后才会去处理event队列。 当两个队列都清空后，dart就会退出。 main方法，来自event队列和microtask队列的所有事件都运行在Dart的main isolate中。 当你要安排一个任务时，请遵守以下规则： 如果可以，尽量将任务放入event队列中。 使用Future的then方法或whenComplete方法来指定任务顺序。 为了保持你app的可响应性，尽量不要将大计算量的任务放入这两个队列。 大计算量的任务放入额外的isolate中。 Isolate通过上面的文章，我们可以知道为什么在上一章节中的异步代码的执行结果都是在main()方法执行完毕后才输出。同时，文章引入了一个新的概念：Isolate。 Dart 没有并发时的共享状态，所有 Dart 代码都是 Isolate 中运行的，包括最初的 main() Isolate（也称为 root Isolate）。Dart 内建了 Isolate 机制，类似于 Actor ，仅在端口（Port）上通过消息进行通信。 每个 Isolate 有它自己的堆（Heap）和栈（Stack），彼此隔离。消息在接收前被复制，这样 Isolate 之间就无法操作相同的对象了。因为状态是彼此隔离的，所以这种并发编程模式不需要锁、互斥量什么的。 每个 Isolate 有它自己的堆内存，这意味着其中所有内存中的值，包括全局数据，都仅对该 Isolate 可见。Isolate 之间的通信只能通过传递消息的机制完成。消息通过端口（port）收发。 Isolate 只是一个概念，具体一个 Isolate 是什么取决于如何实现。比如，在 Dart VM 中一个 Isolate 可能是会是一个线程，在 Web 中可能会是一个 Web Worker 。 创建IsolateDart将Isolate的概念具现化为Isolate类，通过import &#39;dart:isolate&#39;;引入Isolate的包即可调用相关方法。 Isolate以函数作为运行载体——类似于Java中的Thread，最终会运行作为载体所传入的Runnable的run()方法。 创建一个Isolate的方式有两种，分别为spawn()和spawnUri()： 123456789101112131415161718Future&lt;Isolate&gt; spawn&lt;T&gt;( void entryPoint(T message), T message, &#123;bool paused: false, bool errorsAreFatal, SendPort onExit, SendPort onError&#125;)Future&lt;Isolate&gt; spawnUri( Uri uri, List&lt;String&gt; args, var message, &#123;bool paused: false, SendPort onExit, SendPort onError, bool errorsAreFatal, bool checked, Map&lt;String, String&gt; environment, Uri packageRoot, Uri packageConfig, bool automaticPackageResolution: false&#125;) spawn()比较常用的是第一种方法spawn()，传入的参数为返回void类型的函数和该函数的所能接收的参数。例如： 123456789import 'dart:isolate';void newIsolate(_)&#123; print(\"new isolate!\");&#125;void main()&#123; Isolate.spawn(newIsolate, null);&#125; 因为传入的函数必须为可传入参数的类型，所以如果只想调用函数而不需要任何传入值，可以将函数的参数类型设为dymanic，这样调用spawn()时后面可以传入null。 事实上，spawn()方法中说到，通常传入函数的参数类型为SendPort，这样Isolate就可以跟外部的其他Isolate进行通信、传递消息。 spawnUri()Isolate还可以通过URI链接调用对应的dart文件中的main()方法，这种模式有点像远程加载或者动态组件化的意思，因为除了可以调用本地的dart文件，还可以调用远程的dart文件（比如Http资源）。 spawnUri()必须传入的参数有三个，第一个是dart文件所在的URI，第二个参数类似于Java中的main(String[] args)，是一个List&lt;String&gt;类型的，第三个是任意参数，一般为SendPort。 123456789import 'dart:isolate';void main()&#123; var response = new ReceivePort(); Future&lt;Isolate&gt; remote = Isolate.spawnUri(Uri.parse(\"uriEcho.dart\"), [], response.sendPort); remote.then((isolate)&#123; response.close(); &#125;);&#125; 其中uriEcho.dart文件内容如下： 123main()&#123; print(\"uriEcho\");&#125; 在当前版本下，我在本机的测试中发现，如果第三个参数不传入SendPort，spawnUri()不会执行；如果传入SendPort，不手动调用close()的话，主线程会一直等待Isolate返回消息。 值得一提的是，两个创建方法的返回对象都是Future，这意味着可以使用async和await协调处理Isolate 退出Isolate要退出Isolate，调用kill()方法即可，注意kill()方法可传入的参数有两个： Isolate.immediate Isolate.beforeNextEvent 要理解关于这两个函数的含义，需要先了解Isolate类中的变量controlPort。controlPort的类型为SendPort，根据名称可知，该controlPort是用于发送Isolate的相关控制消息。这里的所谓控制消息，根据注释，指的是Isolate的暂停（pause）、终止（terminate）等操作。 Isolate本质上依然是事件队列的循环调用，只是运行环境产生了隔离并且可以并行运行，因此controlPort所发出的控制消息，最终还是发到事件队列中，等待循环执行。 因此调用kill()方法时，根据不同的参数，【终止】这一命令将会位于事件队列中的不同位置。 根据注释的解释，immediate表示将【终止】操作插入到当前事件队列尾部，这表示在终止操作之前的所有控制操作都将被执行；beforeNextEvent表示将【终止】操作插入到当前事件队列正在执行的事件之后。 例如，下面为当前的操作事件队列，队列中目前有N个事件： 1234567891011+-----------+| event 1 |+-----------+| event 2 |+-----------+| || ...... || |+-----------+| event N |+-----------+ 当调用kill(Isolate.immediate)时，immediate的操作事件将插入到操作队列底部： 12345678910111213+-----------+| event 1 |+-----------+| event 2 |+-----------+| || ...... || |+-----------+| event N |+-----------+| immediate | &lt;--- insert+-----------+ 当调用kill(Isolate.beforeNextEvent)时，beforeNextEvent的操作事件插在当前运行的event1事件之下： 12345678910111213+-----------------+| event 1 |+-----------------+| beforeNextEvent | &lt;--- insert+-----------------+| event 2 |+-----------------+| || ...... || |+-----------------+| event N |+-----------------+ 这个是我根据注释作出的理解，也许有不对的地方，因为Isolate没有操作事件相关的监听事件，也没办法进行测试。 测试kill()的功能时可以将Isolate传入的函数内sleep一段时间，不然会觉得kill()没效果。 ReceivePort &amp; SendPortIsolate之间是相互隔离的，要相互传递数据、消息时，就需要依靠ReceivePort和SendPort。这两个类的定义都在dart:isolate的isolate:dart中。 ReceivePort前面也说到，Dart基本所有操作都是基于消息队列的，类似于Android中的Handler。这里的ReceivePort也一样。 1var receivePort = new ReceivePort; 需要注意的一点是，当ReceivePort被创建时起，创建其的Isolate环境将一直运行下去，直到ReceivePort被调用close()。我的推测是ReceivePort不断往Isolate的Event queue填充任务，导致event loop一直无法停止，所以Isolate环境一直在运行。 从ReceivePort的定义中可以看到，它是实现了Stream的接口的，所以使用ReceivePort来接收数据、消息时，可以使用Stream的方式——listen()方法和await-for方式： 12345678910//listen方法receivePort.listen((v)&#123; //TODO: do something here&#125;)//await-forawait for(var msg in receivePort)&#123; var data = msg[0]; //TODO: do something here&#125; 只要不调用close()方法，ReceivePort就会一直接收数据消息。 SendPortSendPort的作用比较简单，查看它类的定义就会发现，它只有一个常用函数： 1void send(var message); 使用方式非常简单，但要注意的是它对发送的消息类型有所限制，能发送的类型有： null num bool double String SendPort List Map Set ReceivePort本身不能被发送 SendPort本身无法被用户创建，它与ReceivePort是绑定在一起的，即初始化一个ReceivePort时，其对应的SendPort作为它的成员变量一同被创建，它们之间是一对一的关系，一个SendPort所发送的消息只能被创建它的ReceivePort所接收。 所以，如果你希望同一个ReceivePort能接收多个不同Isolate内的消息数据，可以将该ReceivePort的SendPort发送给各个Isolate即可。 注意点ReceivePort有一点需要注意，首先其listen()方法定义如下： 12StreamSubscription listen(void onData(var message), &#123;Function onError, void onDone(), bool cancelOnError&#125;); 其中，listen()方法只会回调onData()和onDone()函数，而onError()永远不会被调用，cancelOnError则设置无效，关于这一点在其类定义的注释上有说明。 pause &amp; resume手动调用pause()Isolate允许暂停(pause)和继续(resume)，其分别对应的方法为： 123Capability pause([Capability resumeCapability]);void resume(Capability resumeCapability); 手动调用pause()方法时，如果传入的Capability为null，pause()会返回一个新的Capability对象。 这个Capability对象用于标识一次pause请求，所以按照注释所言，使用同一个Capability对象进行多次pause请求时，只需要使用相同的Capability对象调用resume()一次即可让Isolate继续执行；如果使用不同的Capability对象进行多次pause请求，则需要使用这些不同的Capability对象调用相应的resume()才能让Isolate继续执行。 pause请求有效的前提是Isolate的pauseCapability不为空 初始化调用pause请求在调用spawn()和spawnUri()时，可以设置其中的可选参数paused为true，这样Isolate在初始化完毕后会进入暂停状态，直到调用resume()后才开始执行。 通过这种情况暂停的Isolate，其对应的pause请求的Capability对象为其自身的成员变量pauseCapability，即： 123Isolate.spawn(newIsolate, receivePort.sendPort, pause:true).then((isolate) =&gt; isolate.resume(isolate.pauseCapability)); onError &amp; onExit在spawn()和spawnUri()中，分别有可选参数onError和onExit，此处的传入类型都为SendPort，即Isolate环境中发生的error和执行完毕的exit消息都会通过SendPort发送出去。 前面说过，ReceivePort的listen()只有onData()和onDone()会被回调，因此onError和onExit所传入的SendPort，最终发送出来的消息依然只会回调到其对应的ReceivePort的listen()中的onData()。 因此为了方便辨识对应的消息，一般会为对应的onError和onExit创建相应的ReceivePort。 如果不通过spawn()和spawnUri()传入onError和onExit，Isolate还有相应的函数提供调用： 123void addOnExitListener(SendPort responsePort, &#123;Object response&#125;);void addErrorListener(SendPort port); 这两个函数的效果和spawn()、spawnUri()传入的onError、onExit一致，并且addOnExitListener()方法还有可选参数response，可以设定当Isolate运行完毕退出时发送该response到指定的ReceivePort中，方便识别操作。","link":"/article/dev/2a8afc84.html"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Dart","slug":"Dart","link":"/tags/Dart/"}],"categories":[{"name":"骚灵","slug":"default","link":"/categories/default/"},{"name":"开发","slug":"dev","link":"/categories/dev/"}]}