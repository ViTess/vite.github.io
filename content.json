{"pages":[],"posts":[{"title":"hexo与github建站记","text":"前一段时间Google开放了.app的域名申请，当时我搜了一下自己想要的一个域名，但是感觉有点小贵就没下手，没想到过了几天这个域名就没了。所以火急火燎的买了现在这个域名，但是一时间没想好要干嘛，思来想去的不如就建个小博客站吧。 准备阶段GitHub首先是先在自己的GitHub上创建一个新的Repository，名字为xxx.github.io，这个xxx必须是自己GitHub的用户名，否则不能成功。 创建好之后进入该项目的Settings，找到GitHub Pages 这里要选择自己的显示的分支，网上有人说一定要建gh-pages分支，其实没必要。另外Save之后就无法修改了，所以这里要注意一下。 GitHub Pages支持Jekyll，不过我用hexo，所以这个不用管了。 Custom domain这个是绑定自定义域名到你的github.io上。此处表面上是只能输入一个，实际上可以在项目里建立一个CNAME文件，往里面写入多个自己的域名都行。 Enforce HTTPS 这个重点说一下。今年五月份起 GitHub Pages“支持”HTTPS，这个支持的意思是从五月份起，新建的github.io都必须开启HTTPS，否则不能访问。这里就有个坑，此处暂时不表。 自定义域名网上域名商有很多，国内的域名商需要备案，网上很多人说建议在国外的域名商买域名，这个就见仁见智了，看自己需要。 有一点要注意的是，购买域名后要对域名的DNS做处理，否则是无法访问的。我这个域名实在GoDaddy上买的，GoDaddy的管理页就能设置域名的DNS域和转发网址，嫌麻烦的话其实在里面跟github.io绑定就行。 我用的是Dnspod，目前免费。使用方式是先注册，然后在里面的控制台添加域名（就是自己申请的自定义域名）。 添加完之后点进去，就可以添加记录： 网上一些帖子告诉你这里填的A记录的IP是错的，现在由于要使用HTTPS，所以要用troubleshooting-custom-domains这个页面内提供的四个IP： 185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 由于Dnspod只能免费填2个A记录，所以随便选2个IP填就是了。 之后要去自己买的域名的控制台那边修改DNS域： 图上是修改好的样子。 上述步骤完成后等一段时间，可以用dig命令（我是linux平台）检测一下自己的github.io和自定义域名的A记录是否一致。 坑这里就是1.1里提到的坑。当你设置完上述的所有东西之后，回到GitHub项目的Setting页，很大可能你会在GitHub Pages处看到两种提示，大概是： 自定义域名不支持HTTPS HTTPS证书正在处理下发 这两种提示2选1，都有可能出现。问题是第一个提示，这个非常误导人。我当时以为是我的哪个设置弄错了，折腾很久，还给github.com/contact发了个工单。 但实际上这两个提示根本没什么卵用，你所能做的就是等。一般一个晚上的时间就能好，实在不行就给github发工单。 HexoHexo是基于Node.js的，所以使用之前要先安装好Node，再用npm命令安装。 Hexo的使用其实很简单，主题页很多，官网提供的theme有大概200多个（吐槽一下，大多都是性冷淡色调，虽然我用的这个也是）。唯一要注意的是，网上很多比较过时的文章，里面提到的用法现在都不支持了。事实上官网本身就有简体中文的教程、文档，而且下面还有评论，多看看大概就知道怎么使用了 值得一提的是，Hexo的发布每次都是重新生成所有文件，再全部覆盖提交的GitHub上，所以要注意把不想被覆盖的文件添加到Hexo的source目录里。 还有一点是，Hexo发布到GitHub上的文件都是生成后的文件，Hexo自身的源文件不会上传上去。一种解决方法就是在自己的github.io项目上新建一个分支，将当前的Hexo文件都保存在新分之上。","link":"/article/default/86b00fba.html"},{"title":"The ABC of Dart Part 2","text":"函数函数的写法跟其他语言基本大同小异，如下： 123int func1(String str)&#123; return int.parse(str);&#125; 在以上的函数func1中，声明了返回值为int类型的对象，函数参数为String，这是一种标准写法。 函数的简写动态脚本语言，或者函数式编程语言，特点之一就是函数可以简写，如： 12345678910111213int func1(String str)&#123; return 1;&#125;func2(String str)&#123; return 1;&#125;func3(str)&#123; return 1;&#125;func4(str) =&gt; 1; 因为在Dart中类型是可选的，所以像函数func2缺省声明返回值类型、函数func3缺省声明参数类型的写法都可以，在这种情况下，编译器默认将缺省声明类型的都声明为dynamic。不过个人建议还是不要这样省略，dynamic会让程序员感到困惑。 函数func4是Dart提供的一种新的写法，类似于Java的lambda，当函数内只有一行语句时，可以用=&gt;来简写，即func4代表的函数类型和func3、func2一样。 函数对象 - Function前面说过，Dart中一切皆为对象，函数也不例外，它的对象类型为Function。 12345void func1(String str)&#123; //TODO...&#125;print(func1 is Function);// 打印true 像这样，通过Dart的is关键字用来判断类型，可知函数func1的类型就是Function。 但就我的理解，Function对于函数而言，就是一个基类。所有函数都的类型都基于Function，而每一种函数都有其特定的类型。 比如，上述的函数func1，可以用对象的概念套进去，即func1的基本类型是Function，实际类型是(String) -&gt; void，而fucn1则是这个实际类型的实例的名称。 我认为，需要先理解这个概念，才能明白为何把函数称为第一公民，为何认为一切皆对象。不仅仅是Dart这么语言，目前大多的动态语言、函数式语言都是类似的这种设定。 闭包函数作为一种对象，既然有匿名对象，也就有匿名函数，如下： 12345678//(1)(String name) =&gt; \"Hello $name\";//(2)(name)&#123;print(\"Hello $name\");return 1;&#125; 像(1)、(2)这种把函数名、返回类型缺省的写法就是匿名函数。得益于函数也是对象这个概念，匿名函数这种写法才能实现。 以(1)为例子，匿名函数的写法舍去了函数名和返回类型，编译器会自动推断这段函数的返回类型，同时这段函数的实际类型为(String) -&gt; String。 如果这样一看，就像把一段封装好的逻辑包裹在函数这个对象的体内，因为函数自为对象，所以这个函数具备传递性，它可以被任意拿去调用，而不再像面向对象的语言一样，函数方法依附于实体类，这里就引申出函数式编程最重要的概念：闭包。 函数作为一种对象，因此可以作为返回值，也可以作为参数被传递。关于闭包的概念，寥寥几句无法说得清除。这里给出一种比较思路：比如在Java中，函数方法是作为一个对象的成员，我们要调用一个函数方法，调用它的这段逻辑，必须先传递对象，获取对象；反过来在Dart中，我们也是需要传递对象、获取对象，只是函数此时变成了一个对象，实际上我们依然在跟对象打交道，只是函数对象的出现使得一段逻辑本身就能被打包成一个可传递可获取的对象。 但是闭包不仅限于表示一段函数，而是一段包含了上下文环境的函数，这里还是不多说，只用一段代码表示一下 1234var func = (int a)&#123; int b = 4; return (int c) =&gt; a - b - c;&#125;(1); 在这段代码中，这段代码先定义了一段匿名函数，我们把该匿名函数叫做f1，f1的类型为(int) -&gt; Function，表示返回值是函数。然后我在匿名函数f1后面写上(1)，表示调用f1，传入参数1。f1的内部声明了一个变量int b = 4，并返回了一段匿名函数，我们把这段匿名函数叫做f2，f2的类型为(int) -&gt; int。因为我们调用了f1，所以立刻返回了f2并赋值给声明为动态推断类型的变量func，所以func的类型就是Function，它的实际类型就是f2这段函数。 注意这里的f2函数，其实携带着它的上下文环境——即int b = 4这个变量的。关于这个上下文环境不再多说，此处只作为一个例子。而从这个例子也可以得知，闭包的内存消耗比一般的对象可能要大，因为它包含了上下文环境。 回到开头所说的匿名函数，因为它缺省了函数名，所以在声明一段匿名函数时，必须立刻给它赋值，或者立刻执行它。所以开头的代码(1)、(2)应该这样写： 12345678//(1)var func1 = (String name) =&gt; \"Hello $name\";//(2)(name)&#123;print(\"Hello $name\");return 1;&#125;(\"world\"); 注意： 将匿名函数赋值给某个变量时，需要将变量声明为var或Function。 匿名函数无法在函数外或类外立刻调用，只能声明。 typedeftypedef是Dart中的关键字。我的理解是用于定义函数类型，即将一种函数类型定义成一种对象；而网上的说法是typedef用于定义函数类型的别名。 1typedef int Compare(Object a, Object b); 在上述代码中，将(Object, Object) -&gt; int这种函数的实际类型给予了一个具体的名称Compare，这意味着，一旦任何一个函数的实际类型是(Object, Object) -&gt; int，则这个函数的实际类型等同于Compare。例如： 12345int compareFunc(Object a1, Object b1)&#123; return 0;&#125;print(compareFunc is Compare);//打印true 上述代码中的函数compareFunc的实际类型为(Object, Object) -&gt; int，所以用is来与Compare作判断的结果为true。 之前说过Function代表函数类型，所以作为一种类型，也是可以定义为函数的返回值类型和参数类型。如： 123Function getFunc(int a)&#123; return (int b) =&gt; b - a;&#125; 因为用typedef定义了一段函数类型的名字，所以可以用该名字作为返回值类型或参数类型，如： 12345Compare getFunc(int i)&#123; return (Object a,Object b)&#123; return i; &#125;;&#125; 可选参数可选参数是Dart在函数上增加的新特性，作用如名字一样，当在函数中声明了可选参数，在调用该函数时我们可以选择是否传递该可选参数。 可选参数有两种： 命名可选参数命名可选参数用大括号{}包围，默认值可用:或=来赋值。 12345678void func(int a, &#123;int b:3, c, d&#125;)&#123; //TODO&#125;//调用func(1); //(1)func(1,b:4); //(2)func(1,c:5); //(2) 上述代码中，我们定义了func函数，函数参数中必须要传的是a，剩下的是可传可不传的参数b、c、d，我们用大括号包围。其中某些可选参数我们想要有一个默认值，可以在声明时就用:或者=来赋值，如参数b。 在调用时，我们可以只传必须要传的参数，如(1)。如果我们想要传入某些参数，比如我们要传入参数b，则可以如(2)一样调用，注意因为是命名可选参数，所以在传入可选参数时必须声明传给哪个参数。 位置可选参数位置可选参数用方括号[]包围，默认值用=来赋值。 1234567void func(int a , [int b = 3, c, d])&#123; //TODO&#125;//调用func(1); //(1)func(1,2,3); //(2) 上述代码中，我们定义了func函数，函数参数中必须要传的是a，剩下的是可传可不传的参数b、c、d，我们用中括号包围。其中某些可选参数我们想要有一个默认值，可以在声明时就用=来赋值，如参数b。 表面上，位置可选参数和命名可选参数区别不大。实际上它们的区别在调用时的传参：命名可选参数传参时必须声明传给哪个参数，而位置可选参数则是按顺序来传值的。在(1)中只传必须参数时和命名可选参数一样。但在(2)中可以看到，传参时不需要声明参数名，当我们传入的参数为1、2、3时，函数将分别把参数赋值到a、b、c中。","link":"/article/dev/ca5f159a.html"},{"title":"ViewPager配合Fragment懒加载的一个坑","text":"ViewPager搭配Fragment做懒加载，这个很常见。需要小心的是Fragment在ViewPager中的生命周期，这个不多说。 最近遇到一个坑，这个坑的关键点是 1ViewPager.setOffscreenPageLimit(); 假设通过这个方法设置了一个值（比如2），然后在ViewPager中滑动加载了2个Fragment后，第三个Fragment的加载会出现问题，具体表现是该调用的方法都有调用，但是就是数据加载出问题。 数据加载我是用了RxLifecycle绑定到FragmentEvent.DESTROY_VIEW，初步怀疑是生命周期在作祟。 目前的解决方法是先将setOffscreenPageLimit设置为和自己加入的Fragment数量一致。比较好的解决方法是自定义ViewPager实现懒加载。","link":"/article/dev/fbb3d3e5.html"},{"title":"你可能是数据推荐的受害者","text":"如果你是一名手机应用开发者，应该对友盟之类的统计SDK有所了解。如今这些第三方统计平台越来越吃香，因为各大厂商平台能利用这些数据做的事情，太多了。 最常见的，就是很多平台引以为荣的推荐系统。 最先让普通人体会到数据推荐的威力的，应该是网易云音乐。通过统计用户在网易云音乐上常听的音乐类型，逐步构建出一个用户的喜好模型，根据这个模型来为用户推荐音乐。从市场反应和用户反馈来看，这个推荐系统相当成功。 只要有效数据足够，方法论正确，通过手机收集到的用户数据和行为习惯，互联网公司真的比你自己更了解你。 何况这个时代，收集数据的不仅仅是手机APP，网页、搜索引擎、甚至是线下商店，大家都在无孔不入地收集每个人的数据。 有了这些数据，通过精准推荐，你永远都能在平台上看到你喜欢看的。 这样好吗？对于平台而言当然好，当用户发现这个平台好像大部分是自己感兴趣的内容，用户对平台的粘性就会变高，用数据表达的话，就是留存率增加，使用时长增长。 但是反过来说，对用户而言，你只能看到平台想你看的东西，或者说，你只能看到平台认为你想看的东西。 过去看新闻的时候，某些类型的新闻我可能比较关注，比如科技、民生类的，有一些是不太关注的，比如财经、国外政治类的。但是不关注不代表不看，比如某些时候可能我接触了一些其他知识，对某些之前不关注的新闻有了些许兴趣，那么当新闻实时发布出来时，我就能及时获取到信息；甚至就算不关注，但起码我会看到新闻标题，让我知道世界上发生了这么一回事。 现在看新闻，如果我点击科技、民生类的新闻比较多，可能过一段时间后，这个新闻平台就会开始自作主张地把这类型的新闻都推给你，而其他类的新闻在你浏览的版面上，占比会越来越少，甚至有段时间一条标题都看不到。 这意味着，数据推荐在迎合口味的同时，还把视野的广度给压缩了。这对很多人而言，会形成一种被动的“幸存者偏差”，仿佛这个社会就被你眼前“被推荐”的一切所充斥着，根本不会发生其他你不愿意了解的事情。 本来国家在信息屏蔽上就无所不用其极，数据推荐反而把这种趋势越推越烈。 举个例子，微博过去是很多突发、能让社会关注度很高的事件的消息始发地和传播地，过去刷微博的时候，会很容易就能刷到这些东西。但是近年以来，这些内容在用户充满被推荐的首页上很少出现到，甚至需要用户去搜索才能看到内容。 可以说，数据推荐在进一步加剧群众的无知。 其实数据推荐是一项很好的技术，精准的推荐系统能让广告收益更高，让平台更能抓住用户等等。但问题是，这些平台，好像很少能让用户选择是否接受推荐。 比如百度，如果我经常在百度上搜索计算机开发技术类的关键字，而某一天我可能希望搜索一些与此无关、但包含该关键字的内容，往往百度还是会优先在搜索结果上把技术类内容展示给我；又或者是知乎，知乎首页充斥着我关注的话题、我回答问题的相关内容和我提问的相关内容，但有时候我在知乎上并不只是想看这类东西。过去知乎还没有这种强相关的推荐首页时，可以在某个页面里看到其他人实时发的问题，这些问题涵盖不同方向类别，这让我可以挑一些还没人回答过的、对某些方面有经验或者兴趣的问题作答。而现在，知乎早就把这个功能去掉了。 如今数据推荐就像是应用里的隐私声明，你只能选择接受——说难听点，你只能选择被数据推荐强奸你的视野。事实是，数据推荐很有趣，但有的时候，我应该有选择不被推荐的权利。","link":"/article/default/4da69769.html"},{"title":"The ABC of Dart Part 1","text":"前言近期对Flutter有兴趣，但这个东西要用Dart来写应用，只能先入门一下这门语言。 目前把基础看了一部分，总体而言，Dart和目前比较火热的JavaScript、Kotlin一样是一门脚本式语言，支持函数式编程，函数依然是第一公民，不过Dart对于对象的支持和定义更详细。另外，Dart运行在自己的Dart VM上，和其他的JVM语言不同，所以无论是使用Flutter或者是Dart，都需要先安装Dart VM。 至于IDE，我用的Android Studio，安装上Dart插件即可。 Hello World!和C语言一样，Dart的程序入口在main函数： 123void main()&#123; print(\"Hello World\");&#125; 三行代码就可以在一个*.dart文件中运行，不需要import什么东西。 对象类型之所以说是“对象类型”，是因为在Dart中一切皆为对象，只是针对不同的对象有不同的默认类型。因此，所有对象的默认值都为null，判空不用像js那么夸张了。 Object先介绍Object，就如上面所说，一切类型都是Object或者Object派生的。如果点开Dart中的object.dart，第一句注释就是： The base class for all Dart objects. 即所有类型都隐藏式继承了Object，如Java一样。 dynamicdynamic表示任意未知类型。注意未知这个词。在Dart中，Object和dynamic都能表示所有类型。关于这一点，刚开始接触时确实很困惑——既然Object已经能表示一切类型，那dynamic是用来干嘛的？ 举个例子，我创建一个类ClassA，其中的有一个成员函数为a： 12345class ClassA&#123; void a()&#123; //TODO &#125;&#125; 我声明一个函数，叫做func1，假设函数定义如下： 1234void func1(Object object)&#123; object.toString(); //(1) object.a(); //(2)&#125; 因为ClassA默认继承了Object，所以在给func1这个函数传参时，我们可以传入ClassA的实例。但是在编译时，编译器会报错，告诉我们第(2)行代码是不能编译过去的。因为函数func1声明了函数参数类型为Object，它只能调用Object的方法。 但如果我把func1的参数改为dynamic： 1234void func1(dynamic object)&#123; object.toString(); //(1) object.a(); //(2)&#125; 此时编译器则可以编译运行。 为什么呢？前面已经说了，Object是所有类的基类，而dynamic代表任意未知类型。两者功能基本一样，但是当使用dynamic来声明参数时，你可以通过该参数调用任意函数或变量，而编译器不会报任何异常。因为dynamic修饰的变量在编译器眼中看来，它是属于未知的，编译器不知道这个变量是否真的有这个函数或者变量，所以编译器选择闭嘴。 所以什么时候应该显示声明参数为dynamic呢？比如说我有一个类ClassA和ClassB，它们是两个没有任何关系的类，但是它们有两个共同的函数a，那么函数func1就能接受ClassA和ClassB的实例并且在内部调用函数a，而编译器不会对此报错。 但是官方也说到，最好还是不要用这种方式，dynamic应该尽可能不用，因为它不会被编译器检查，这样会导致程序不安全，程序员看着也很难猜测这种参数是什么类型。毕竟动态语言太过于“动态”就很难看了。 值得一提，Dart的静态检查和动态检查都很优秀，语言虽然是动态的，但是写起来跟静态强类型的语言相差不大。 var很多语言都有var关键字，作用基本都一样，表示类型为动态推断类型，编译器会将var声明的东西根据赋值反推类型。比如： 12var p1 = 1;var p2 = \"2\"; 在IDE中，这样在IDE中，能实时看到p1的static type为int，p2的static type为String。通过打印各自的runtimeType，也能看到和上述static type相似。 接下来有一点就有点意思了。如果我这样写： 123var p3; //(1)p3 = 1; //(2)p3 = \"2\"; //(3) 如果这样写，是可以编译、运行的（我目前的版本为Dart VM Version: 2.0.0-dev.54.0，往后的版本就不好说了）。 因为在（1）中，p3被动态推断为dynamic类型，所以在（2）中p3可以赋值为int，在（3）中可以赋值为String。在IDE中可以看到p3的static type为dynamic，而分别打印（2）、（3）时的runtimeType则分别为int和String。 所以，使用var最好是及时赋值，让编译器可以推断出实际类型，否则推断出类型为dynamic后，往后调用可能会出现不安全的情况。 num所有数字类型都继承自num，而数字类型也就只有2个： int - 表示任意长度的整数 double - 表示双精度浮点数 Dart中没有float、long、short、byte这些类型，统统用以上两种表示。 String字符串类型。顺带一提Dart也没有char类型。 Dart中的字符串支持+操作符，即： 12String str1 = \"abc\";String str2 = str1 + \"d\"; //str2 = \"abcd\" String支持在字符串中插入变量和代码，如： 123String str1 = \"abc\";String str2 = \"$str1\"; //str2 = \"abc\"String str3 = \"$&#123;str1.compareTo(str2)&#125;\" //str3 = \"true\"; 字符串前面加r，可以避免转义作用，声明该字符串为原始字符串： 12String str1 = \"\\n\";//输出换行String str2 = r\"\\n\";//输出\"\\n\" bool布尔类型，这个不用多说。 这些就是常用的基本类型，剩下的容器类型迟些再说。 const和finalconst和final都用于修饰不可修改的常量，唯一的不同点是在其声明时： const声明的常量是编译时常量，即编译时就需要确定值，所以声明时需要指定明确的值。 final声明的常量是运行时常量，即实际运行时才确定常量的值。 例如： 12345const int p1 = 1; //(1)final int p2 = 2; //(2)const int p3 = p1.compareTo(p2); //(3)final int p4 = p1.compareTo(p2); //(4) 在上面的代码中，（1）、（2）、（4）都可以编译运行，（3）在编译时则会提示错误。","link":"/article/dev/53564420.html"}],"tags":[{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"Dart","slug":"Dart","link":"/tags/Dart/"},{"name":"Android","slug":"Android","link":"/tags/Android/"}],"categories":[{"name":"骚灵","slug":"default","link":"/categories/default/"},{"name":"开发","slug":"dev","link":"/categories/dev/"}]}